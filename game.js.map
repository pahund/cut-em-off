{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/directions/constants.js","webpack:///./src/utils/calculateCameraCoordinates.js","webpack:///./src/utils/degreesToRadians.js","webpack:///./src/utils/getRandomInt.js","webpack:///./src/utils/collides.js","webpack:///./src/utils/isValidTile.js","webpack:///./src/directions/directionIsAllowed.js","webpack:///./src/directions/switchDirection.js","webpack:///./src/directions/directionSwitchMap.js","webpack:///./src/directions/isIntersection.js","webpack:///./src/directions/getNextTile.js","webpack:///./src/config.js","webpack:///./src/pubsub/pubsub.js","webpack:///./src/pubsub/constants.js","webpack:///./src/loop/createLoop.js","webpack:///./src/loop/utils/moveCamera.js","webpack:///./src/map/mapData.js","webpack:///./src/map/tilesheet/drawCurve.js","webpack:///./src/map/tilesheet/utils/krakel.js","webpack:///./src/map/tilesheet/drawStraight.js","webpack:///./src/map/tilesheet/drawTSection.js","webpack:///./src/map/tilesheet/drawCrossing.js","webpack:///./src/map/tilesheet/drawServer.js","webpack:///./src/map/tilesheet/drawTerminus.js","webpack:///./src/tileEngine/createTileEngine.js","webpack:///./src/map/createMap.js","webpack:///./src/map/utils/addPadding.js","webpack:///./src/map/tilesheet/createTilesheet.js","webpack:///./src/messageBox/messageBox.js","webpack:///./src/player/createPlayer.js","webpack:///./src/player/drawPlayer.js","webpack:///./src/utils/calculateRotation.js","webpack:///./src/player/updatePlayer.js","webpack:///./src/player/utils/getKey.js","webpack:///./src/player/utils/isInTheMiddle.js","webpack:///./src/pathfinder/utils/extractShortest.js","webpack:///./src/pathfinder/utils/findShortestPath.js","webpack:///./src/pathfinder/utils/findPaths.js","webpack:///./src/pathfinder/utils/convertMapToGraph.js","webpack:///./src/pathfinder/utils/getNodeByCoords.js","webpack:///./src/pathfinder/utils/initGraphAndAllowed.js","webpack:///./src/pathfinder/pathfinder.js","webpack:///./src/user/createUser.js","webpack:///./src/user/constants.js","webpack:///./src/user/drawUser.js","webpack:///./src/virus/createVirus.js","webpack:///./src/virus/updateVirus.js","webpack:///./src/virus/utils/moveVirus.js","webpack:///./src/virus/utils/isInTheMiddle.js","webpack:///./src/virus/utils/getBestDirections.js","webpack:///./src/directions/getOppositeDirection.js","webpack:///./src/virus/drawVirus.js","webpack:///./src/virus/createBlip.js","webpack:///./src/virus/drawBlip.js","webpack:///./src/virus/Blips.js","webpack:///./src/bomb/createBomb.js","webpack:///./src/bomb/constants.js","webpack:///./src/bomb/drawBomb.js","webpack:///./src/bomb/drawBombWithFuse.js","webpack:///./src/bomb/updateBomb.js","webpack:///./src/bomb/createShrapnel.js","webpack:///./src/bomb/drawShrapnel.js","webpack:///./vendor/sfxr.js","webpack:///./src/audio/ArcadeAudio.js","webpack:///./src/audio/sounds.js","webpack:///./src/audio/index.js","webpack:///./src/index.js","webpack:///./src/canvas/createCanvas.js","webpack:///./src/pathfinder/initPathfinder.js","webpack:///./src/bomb/Bombs.js","webpack:///./src/user/Users.js","webpack:///./src/utils/multiCollides.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","N","E","S","W","degreesToRadians","degrees","Math","PI","getRandomInt","a","b","min","max","floor","random","collides","sprite1","sprite2","dx","x","dy","y","sqrt","collisionRadius","isValidTile","tile","map","direction","tileAtLayer","directionSwitchMap","allowed","includes","nextTile","getNextTile","switchDirection","curr","Error","nextDirection","change","directionIsAllowed","otherDirections","filter","dir","length","1","[object Object]","2","3","4","5","6","9","10","11","12","13","17","18","19","20","14","38","intersectionTiles","entries","push","Number","tileWidth","tileHeight","canvasWidth","canvasHeight","pubsub","this","subscribers","message","callback","incomingMessage","payload","forEach","DROP_BOMB","BOMB_EXPLODES","INFECTED","DROP_SHIP","player","virus","users","bombs","shipMoving","subscribe","kontra","gameLoop","update","infect","sy","sx","moveCamera","render","mapData","calculatePointOnArc","deg","cos","sin","drawCurve","ctx","row","col","broken","save","translate","rotate","lineWidth","strokeStyle","beginPath","moveTo","arc","lineTo","stroke","restore","krakel","data","draw","drawStraight","drawTSection","drawCrossing","drawServer","drawTerminus","createTileEngine","properties","width","height","mapWidth","mapHeight","context","canvas","offscreenCanvas","document","createElement","offscreenContext","getContext","sxMax","syMax","_sx","_sy","layerOrder","tileEngine","tilesets","layers","addTilesets","concat","tileset","tilesetImage","image","firstGrid","lastTileset","tiles","Infinity","path","lastIndexOf","substr","assets","images","numTiles","lastGrid","sort","addLayers","layer","undefined","Array","isArray","zIndex","prop","JSON","parse","e","layerIndex","dataIndex","len","renderTile","preRenderImage","layerId","position","getIndex","index","drawImage","renderLayer","getRow","getCol","startX","startY","viewWidth","ceil","tileOffset","w","count","getTileset","getXAndY","mapX","mapY","currTile","clear","clearRect","createMap","calculateCameraCoordinates","paddedMap","arr","h","pad","retVal","idx","addPadding","Image","src","toDataURL","Promise","resolve","setTimeout","createTilesheet","messageBox","timeoutHandler","div","style","cssText","getElementById","appendChild","clearTimeout","transition","innerHTML","backgroundColor","color","createPlayer","infected","gameOver","dropBomb","scale","dropping","bombCoolingDown","updatePlayer","drawPlayer","show","publish","sprite","calculateRotation","fillStyle","closePath","fill","keys","pressed","getKey","isInTheMiddle","getRowAndCol","extractShortest","predecessors","end","nodes","u","reverse","findShortestPath","graph","start","shift","shortest","findPaths","apply","slice","costs","Map","open","addToOpen","cost","vertex","vertices","set","size","currentCost","from","bucket","node","adjacentNodes","delete","totalCost","vertexCost","convertMapToGraph","initGraphAndAllowed","adjacent","currAllowed","target","getNodeByCoords","layerData","pathfinder","coords","args","findShortestPathByCoords","status","ONLINE","drawUser","constants_INFECTED","OFFLINE","spriteMapping","fg","bg","createVirus","blips","Blips","updateVirus","drawVirus","updateVirus_visits","moveVirus","utils_isInTheMiddle","isIntersection","bestDirections","viable","visits","minVis","MAX_SAFE_INTEGER","vis","getBestDirections","getOppositeDirection","createBlip","ttl","radius","drawBlip","setInterval","blip","fuseLength","FUSE_BURNING","shrapnel","explosionDuration","updateBomb","drawBomb","drawBombWithFuse","fuseDeg","sparkCX","sparkCY","sparkX","sparkY","fillRect","createShrapnel","changeTile","speed","rotation","rotationDir","drawShrapnel","synth","_envelopeLength0","_envelopeLength1","_envelopeLength2","_period","_maxPeriod","_slide","_deltaSlide","_changeAmount","_changeTime","_changeLimit","_squareDuty","_dutySweep","_params","setSettings","values","String","fromCharCode","totalTime","multiplier","reset","f","g","totalReset","synthWave","buffer","_filters","v","_hpFilterCutoff","_hpFilterDeltaCutoff","_lpFilterCutoff","_lpFilterDeltaCutoff","_lpFilterOn","_masterVolume","_minFreqency","_phaser","q","_phaserDeltaOffset","_phaserOffset","_repeatLimit","_sustainPunch","_vibratoAmplitude","j","_vibratoSpeed","k","_waveType","_envelopeLength","_envelopeOverLength0","_envelopeOverLength1","_envelopeOverLength2","_lpFilterDamping","_lpFilterOldPos","_periodTemp","_phaserInt","_pos","_finished","_envelopeStage","_envelopeTime","_envelopeVolume","_hpFilterPos","_lpFilterDeltaPos","_lpFilterPos","_phase","_phaserPos","_repeatTime","_sample","_superSample","_vibratoPhase","_phaserBuffer","_noiseBuffer","abs","sfxr","settings","envelopeFullLength","Uint8Array","used","Uint16Array","dv","Uint32Array","base64Characters","output","ArcadeAudio","sounds","aa","add","generateSounds","elem","tick","pool","audio","Audio","play","sound","soundData","createCanvas","init","setDataFromMap","changedMap","initPathfinder","mapCoords","find","createBomb","bomb","createUser","viruses","virusesWithRowAndCol","goneOffline","user","isReachable","online","offline","getStats","flash","reduce","acc","userVirusCollisions","arr1","arr2","collisions","i1","i2","multiCollides","updateOnlineStatus","loop","createLoop","console","log"],"mappings":"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","file":"game.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export const N = 'N';\nexport const E = 'E';\nexport const S = 'S';\nexport const W = 'W';\n","import { tileHeight, tileWidth, canvasWidth, canvasHeight } from '../config.js';\n\nexport default ({ col, row }) => ({\n    sx: col * tileWidth - canvasWidth / 2 + tileWidth / 2,\n    sy: row * tileHeight - canvasHeight / 2 + tileHeight / 2\n});\n","export default degrees => (degrees * Math.PI) / 180;\n","export default (a, b) => {\n    const min = Math.min(a, b);\n    const max = Math.max(a, b);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n","export default (sprite1, sprite2) => {\n    const dx = sprite1.x - sprite2.x;\n    const dy = sprite1.y - sprite2.y;\n    return Math.sqrt(dx * dx + dy * dy) < sprite1.collisionRadius + sprite2.collisionRadius;\n};\n","export default tile => (tile > 0 && tile < 25) || (tile > 30 && tile < 33) || (tile > 37 && tile < 41) || tile > 44;\n","import { directionSwitchMap, getNextTile } from './index.js';\nimport { isValidTile } from '../utils/index.js';\n\nexport default (map, { x, y }, direction) => {\n    const tile = map.tileAtLayer('main', { x, y });\n    if (!isValidTile(tile) || !directionSwitchMap[tile].allowed.includes(direction)) {\n        return false;\n    }\n    const nextTile = getNextTile(map, { x, y }, direction);\n    return isValidTile(nextTile);\n};\n","import { directionSwitchMap, directionIsAllowed } from './index.js';\nimport { isValidTile, getRandomInt } from '../utils/index.js';\n\nexport default (map, { x, y }, curr) => {\n    const tile = map.tileAtLayer('main', { x, y });\n    /* player accidentally stepped onto a broken conduit tile */\n    if (!isValidTile(tile)) {\n        throw new Error('dropped');\n    }\n    const nextDirection = directionSwitchMap[tile].change[curr] || curr;\n    if (directionIsAllowed(map, { x, y }, nextDirection)) {\n        return nextDirection;\n    }\n    const otherDirections = directionSwitchMap[tile].allowed.filter(dir => directionIsAllowed(map, { x, y }, dir));\n    switch (otherDirections.length) {\n        case 0:\n            /* oh no, player locked themselves in! */\n            throw new Error('locked in');\n        case 1:\n            return otherDirections[0];\n        default:\n            return otherDirections[getRandomInt(0, otherDirections.length - 1)];\n    }\n};\n","import { N, E, S, W } from './index.js';\n\nexport default {\n    // curve from S to E\n    1: {\n        allowed: [S, E],\n        change: {\n            [N]: E,\n            [W]: S\n        }\n    },\n    // curve from W to S\n    2: {\n        allowed: [W, S],\n        change: {\n            [N]: W,\n            [E]: S\n        }\n    },\n    // straight from N to S\n    3: {\n        allowed: [N, S],\n        change: {}\n    },\n    // T section W, N, E\n    4: {\n        allowed: [W, N, E],\n        change: {\n            [S]: N\n        }\n    },\n    // T section N, E, S\n    5: {\n        allowed: [N, E, S],\n        change: {\n            [W]: E\n        }\n    },\n    // T section W, E, S\n    6: {\n        allowed: [W, E, S],\n        change: {\n            [N]: S\n        }\n    },\n    // curve from N to E\n    9: {\n        allowed: [N, E],\n        change: {\n            [S]: E,\n            [W]: N\n        }\n    },\n    // curve from W to N\n    10: {\n        allowed: [W, N],\n        change: {\n            [E]: N,\n            [S]: W\n        }\n    },\n    // straight from W to E\n    11: {\n        allowed: [W, E],\n        change: {}\n    },\n    // crossing\n    12: {\n        allowed: [N, E, S, W],\n        change: {}\n    },\n    // T section N, S, W\n    13: {\n        allowed: [N, S, W],\n        change: {\n            [E]: W\n        }\n    },\n    // terminus S\n    17: {\n        allowed: [S],\n        change: {\n            [N]: S\n        }\n    },\n    // terminus W\n    18: {\n        allowed: [W],\n        change: {\n            [E]: W\n        }\n    },\n    // terminus N\n    19: {\n        allowed: [N],\n        change: {\n            [S]: N\n        }\n    },\n    // terminus E\n    20: {\n        allowed: [E],\n        change: {\n            [W]: E\n        }\n    },\n\n    /* FIXME: servers should be sprites */\n    // server\n    14: {\n        allowed: [N, S],\n        change: {}\n    },\n    // broken server\n    38: {\n        allowed: [N, S],\n        change: {}\n    }\n};\n","import { directionSwitchMap } from './index.js';\n\nconst intersectionTiles = [];\nfor (const [tile, { allowed }] of Object.entries(directionSwitchMap)) {\n    if (allowed.length > 2) {\n        intersectionTiles.push(Number(tile));\n    }\n}\n\nexport default tile => intersectionTiles.includes(tile);\n","import { N, E, S, W } from './index.js';\nimport { tileHeight, tileWidth } from '../config.js';\n\nexport default (map, { x, y }, direction) =>\n    map.tileAtLayer('main', {\n        x: direction === E ? x + tileWidth : direction === W ? x - tileWidth : x,\n        y: direction === N ? y - tileHeight : direction === S ? y + tileHeight : y\n    });\n","import { N, W } from './directions/index.js';\n\nexport const canvasWidth = 800;\nexport const canvasHeight = 600;\n\n/* map */\nexport const tileWidth = 100;\nexport const tileHeight = 100;\nexport const mapWidth = 20;\nexport const mapHeight = 20;\nexport const mapPadding = 4;\n\n/* player */\nexport const playerStartCol = 8;\nexport const playerStartRow = 9;\nexport const playerStartDirection = N;\nexport const playerSpeed = 5;\n\n/* virus */\nexport const virusStartCol = 8;\nexport const virusStartRow = 7;\nexport const virusStartDirection = W;\nexport const virusSpeed = 2.5;\nexport const virusBlipInterval = 1000;\nexport const virusBlipTtl = 180;\n\n/* colors */\nexport const lightGreen = '#75a042';\nexport const darkGreen = '#365b1d';\nexport const lightBlue = '#52638a';\nexport const darkBlue = '#2b3653';\nexport const lightRed = '#cd3926';\nexport const darkRed = '#7a2431';\n\nexport const collisionRadius = 30;\nexport const bombCooldown = 100;\n","// exported for testing\nexport class Pubsub {\n    constructor() {\n        this.subscribers = [];\n    }\n    subscribe(message, callback) {\n        this.subscribers.push({ message, callback });\n    }\n    publish(incomingMessage, payload) {\n        this.subscribers.forEach(({ message, callback }) => message === incomingMessage && callback(payload));\n    }\n}\n\nexport default new Pubsub();\n","export const GAME_OVER = 0;\nexport const DROP_BOMB = 1;\nexport const BOMB_EXPLODES = 6;\nexport const INFECTED = 7;\nexport const DROP_SHIP = 2;\nexport const MAP_CHANGED = 3;\nexport const USERS_POSSIBLY_OFFLINE = 4;\n","/* global kontra */\n\nimport { moveCamera } from './utils/index.js';\nimport { pubsub, DROP_SHIP } from '../pubsub/index.js';\n\nexport default ({ map, player, virus, users, bombs }) => {\n    const times = [];\n    let fps;\n    let shipMoving = true;\n    pubsub.subscribe(DROP_SHIP, () => (shipMoving = false));\n\n    return kontra.gameLoop({\n        update() {\n            virus.update();\n            player.update();\n            player.infect(virus);\n            if (shipMoving) {\n                moveCamera(map, player.direction);\n            }\n            users.update();\n            users.infect(virus);\n            bombs.update();\n        },\n        render() {\n            map.render();\n            users.render();\n            bombs.render();\n            player.render();\n            virus.render();\n            if (process.env.NODE_ENV === 'development') {\n                const now = performance.now();\n                while (times.length > 0 && times[0] <= now - 1000) {\n                    times.shift();\n                }\n                times.push(now);\n                fps = times.length;\n                const { row, col } = map.getRowAndCol({ x: 400, y: 300 });\n\n                // eslint-disable-next-line no-param-reassign\n                window.devbox.innerHTML = `${fps} fps – sx=${map.sx}, sy=${map.sy}, row=${row}, col=${col}`;\n            }\n        }\n    });\n};\n","import { playerSpeed } from '../../config.js';\nimport { N, E, S, W } from '../../directions/index.js';\n\nexport default (map, direction) => {\n    switch (direction) {\n        case N:\n            // eslint-disable-next-line no-param-reassign\n            map.sy -= playerSpeed;\n            break;\n        case E:\n            // eslint-disable-next-line no-param-reassign\n            map.sx += playerSpeed;\n            break;\n        case S:\n            // eslint-disable-next-line no-param-reassign\n            map.sy += playerSpeed;\n            break;\n        case W:\n            // eslint-disable-next-line no-param-reassign\n            map.sx -= playerSpeed;\n            break;\n        default:\n    }\n};\n","// prettier-ignore\nexport default [\n    0, 17,  0,  0,  0, 17,  0,  0,  0, 17,  0,  0,  0, 17,  0,  0,  0, 17,  0,  0,\n   20,  4, 11,  2,  1,  4,  2,  0,  0,  5, 11,  6, 11, 13,  0,  1, 11, 12,  2,  0,\n    0,  1, 11, 10,  9, 11, 13,  0,  0,  3,  0,  3,  0,  5, 11, 13,  0,  3,  3,  0,\n    0,  3,  1, 11,  6, 11, 10,  0,  1,  4,  2,  9, 11, 13,  0,  9, 11, 10,  3,  0,\n    0,  3,  3,  0,  3,  0,  0,  0,  3,  1, 13,  0,  0,  3,  0,  0,  0,  0,  5, 18,\n    0,  3,  3,  0, 14,  0,  1, 11, 10,  3,  9, 11,  6,  4, 11,  6,  2,  0,  3,  0,\n    0,  3,  3,  0,  3,  0,  3,  0,  0,  3,  0,  0,  3,  0,  0,  3,  3,  0,  3,  0,\n    0,  9, 13,  0,  5, 11, 10,  0,  0,  3,  1, 11, 10,  0,  0,  3,  3,  0,  3,  0,\n    0,  0,  3,  0,  3,  0,  0,  0,  1,  4, 10,  0,  0,  0,  0,  3,  5, 11,  4, 18,\n    0,  1, 13,  0,  5, 11,  2,  0,  3,  0,  1, 11, 11, 11, 11, 12, 10,  0,  0,  0,\n    0,  3,  3,  0,  3,  0,  5, 11, 13,  0,  9, 11,  2,  0,  0,  3,  0,  0,  1, 18,\n    0,  9, 10,  0,  5, 11, 10,  0,  9, 11, 11, 11, 12, 11,  6, 10,  0,  0,  3,  0,\n    0,  0,  0,  0,  3,  1, 11,  2,  1, 11, 11, 11, 10,  0,  3,  0,  1, 11,  4, 18,\n   20,  6,  6, 11, 10,  3,  0,  3,  3,  0,  0,  0,  1,  2,  9, 11, 12, 11,  2,  0,\n    0,  3,  3,  0,  0,  3,  0,  3,  3,  1, 11,  2,  3,  3,  0,  0,  3,  0,  3,  0,\n    0,  5,  4,  2,  0,  5, 11, 10,  3,  3,  0,  5, 12,  4, 11, 11, 13,  0,  5, 18,\n    0,  3,  0,  5, 11, 12, 11,  6, 10,  9,  6, 10,  3,  0,  0,  0,  9, 11, 10,  0,\n   20,  4, 11, 13,  0,  3,  0,  9, 11, 11, 13,  0,  9, 11,  6, 11,  6,  6, 11, 18,\n    0,  0,  0,  3,  0,  3,  0,  0,  0,  0,  5, 11, 11,  2,  3,  0,  3,  3,  0,  0,\n    0,  0,  0, 19,  0, 19,  0,  0,  0,  0, 19,  0,  0, 19,  9, 11, 10, 19,  0,  0\n];\n","/* eslint-disable no-param-reassign */\nimport { degreesToRadians as deg2rad } from '../../utils/index.js';\nimport { tileHeight, tileWidth, lightBlue } from '../../config.js';\n\nfunction calculatePointOnArc(deg, r) {\n    return [Math.cos(deg2rad(deg)) * r + 50, Math.sin(deg2rad(deg)) * r + 50];\n}\n\nexport default ({ ctx, row, col, deg, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.rotate(deg2rad(deg));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        ctx.moveTo(20, 50);\n        ctx.arc(50, 50, 30, deg2rad(180), deg2rad(190));\n        ctx.moveTo(...calculatePointOnArc(190, 30));\n        ctx.lineTo(10, 45);\n        ctx.lineTo(10, 35);\n        ctx.lineTo(-10, 40);\n        ctx.lineTo(...calculatePointOnArc(190, 70));\n        ctx.arc(50, 50, 70, deg2rad(190), deg2rad(180), true);\n        ctx.moveTo(50, 20);\n        ctx.arc(50, 50, 30, deg2rad(270), deg2rad(260), true);\n        ctx.moveTo(...calculatePointOnArc(260, 30));\n        ctx.lineTo(40, 10);\n        ctx.lineTo(45, 0);\n        ctx.lineTo(35, 0);\n        ctx.lineTo(...calculatePointOnArc(260, 70));\n        ctx.arc(50, 50, 70, deg2rad(260), deg2rad(270));\n    } else {\n        ctx.moveTo(20, 50);\n        ctx.arc(50, 50, 30, deg2rad(180), deg2rad(270));\n        ctx.moveTo(-20, 50);\n        ctx.arc(50, 50, 70, deg2rad(180), deg2rad(270));\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","/* creates canvas moveTo and lineTo commands from arrays; doing this mostly to save a couple of bytes */\nexport default (ctx, data) => data.forEach(([draw, x, y]) => ctx[draw ? 'lineTo' : 'moveTo'](x, y));\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config.js';\nimport { degreesToRadians as deg2rad } from '../../utils/index.js';\nimport { krakel } from './utils/index.js';\n\nexport default ({ ctx, row, col, deg, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.rotate(deg2rad(deg));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        krakel(ctx, [\n            [0, -20, 50],\n            [1, -20, 30],\n            [1, -10, 40],\n            [1, 0, 25],\n            [1, 10, 35],\n            [1, 20, 30],\n            [1, 20, 50],\n            [0, -20, -50],\n            [1, -20, -40],\n            [1, -10, -25],\n            [1, 0, -35],\n            [1, 10, -30],\n            [1, 20, -40],\n            [1, 20, -50]\n        ]);\n    } else {\n        krakel(ctx, [[0, -20, -50], [1, -20, 50], [0, 20, -50], [1, 20, 50]]);\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config.js';\nimport { degreesToRadians as deg2rad } from '../../utils/index.js';\nimport { krakel } from './utils/index.js';\n\nexport default ({ ctx, row, col, deg, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.rotate(deg2rad(deg));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        krakel(ctx, [\n            [0, 50, 20],\n            [1, 40, 20],\n            [1, 45, 10],\n            [1, 40, -10],\n            [1, 45, -20],\n            [1, 50, -20],\n            [0, 20, -50],\n            [1, 20, -35],\n            [1, 10, -40],\n            [1, 0, -30],\n            [1, -10, -40],\n            [1, -20, -35],\n            [1, -20, -50],\n            [0, -50, -20],\n            [1, -40, -20],\n            [1, -35, -10],\n            [1, -45, 0],\n            [1, -30, 10],\n            [1, -35, 20],\n            [1, -50, 20]\n        ]);\n    } else {\n        krakel(ctx, [\n            [0, -20, -50],\n            [1, -20, -20],\n            [1, -50, -20],\n            [0, 20, -50],\n            [1, 20, -20],\n            [1, 50, -20],\n            [0, -50, 20],\n            [1, 50, 20]\n        ]);\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config.js';\nimport { krakel } from './utils/index.js';\n\nexport default ({ ctx, row, col, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        krakel(ctx, [\n            [0, -20, 50],\n            [1, -20, 45],\n            [1, -10, 40],\n            [1, 0, 45],\n            [1, 10, 35],\n            [1, 20, 40],\n            [1, 20, 50],\n            [0, 50, 20],\n            [1, 40, 20],\n            [1, 45, 10],\n            [1, 40, -10],\n            [1, 45, -20],\n            [1, 50, -20],\n            [0, 20, -50],\n            [1, 20, -35],\n            [1, 10, -40],\n            [1, 0, -30],\n            [1, -10, -40],\n            [1, -20, -35],\n            [1, -20, -50],\n            [0, -50, -20],\n            [1, -40, -20],\n            [1, -35, -10],\n            [1, -45, 0],\n            [1, -30, 10],\n            [1, -35, 20],\n            [1, -50, 20]\n        ]);\n    } else {\n        krakel(ctx, [\n            [0, -20, -50],\n            [1, -20, -20],\n            [1, -50, -20],\n            [0, 20, -50],\n            [1, 20, -20],\n            [1, 50, -20],\n            [0, -50, 20],\n            [1, -20, 20],\n            [1, -20, 50],\n            [0, 50, 20],\n            [1, 20, 20],\n            [1, 20, 50]\n        ]);\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config.js';\nimport { krakel } from './utils/index.js';\n\nexport default ({ ctx, row, col, broken }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    krakel(ctx, [\n        [0, 30, -48],\n        [1, 48, -30],\n        [1, 48, 30],\n        [1, 30, 48],\n        [1, -30, 48],\n        [1, -48, 30],\n        [1, -48, -30],\n        [1, -30, -48],\n        [1, 30, -48]\n    ]);\n    ctx.stroke();\n    if (broken) {\n        ctx.lineWidth = 2;\n        krakel(ctx, [\n            [0, 10, -48],\n            [1, 0, -40],\n            [0, 24, -48],\n            [1, 20, -30],\n            [0, 48, -27],\n            [1, 20, -20],\n            [0, -10, -30],\n            [1, 10, -30],\n            [1, 30, -10],\n            [1, 20, 0],\n            [1, 10, 0],\n            [0, 48, 7],\n            [1, 30, 10],\n            [0, 20, 0],\n            [1, 30, 10],\n            [1, 10, 20],\n            [0, 30, 48],\n            [1, 30, 30],\n            [1, 10, 30],\n            [0, 20, 20],\n            [1, 20, 30],\n            [0, -10, 48],\n            [1, -10, 20],\n            [1, 0, 10],\n            [0, -20, 0],\n            [1, -20, 20],\n            [1, -10, 30],\n            [0, -30, 48],\n            [1, -20, 40],\n            [1, -20, 30],\n            [0, -30, 30],\n            [1, -20, 40],\n            [0, -48, 20],\n            [1, -30, 20],\n            [0, -40, 20],\n            [1, -40, 10],\n            [0, -48, 0],\n            [1, -30, 0],\n            [1, -20, -10],\n            [0, -40, 0],\n            [1, -30, 10],\n            [0, -48, -17],\n            [1, -40, -30],\n            [1, -30, -20],\n            [0, -30, -48],\n            [1, -10, -20],\n            [1, -10, -10],\n            [0, -20, -30],\n            [1, -20, -20],\n            [1, -30, -10]\n        ]);\n        ctx.stroke();\n    }\n    ctx.restore();\n};\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config.js';\nimport { degreesToRadians as deg2rad } from '../../utils/index.js';\nimport { krakel } from './utils/index.js';\n\nexport default ({ ctx, row, col, deg, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.rotate(deg2rad(deg));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        krakel(ctx, [[0, -20, 50], [1, -20, 40], [1, -10, 45], [1, 0, 35], [1, 10, 45], [1, 20, 40], [1, 20, 50]]);\n    } else {\n        krakel(ctx, [[0, -20, 50], [1, -20, 0], [1, 20, 0], [1, 20, 50]]);\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","/* global kontra */\n\n/**\n * A tile engine for rendering tilesets. Works well with the tile engine program Tiled.\n * @memberof kontra\n *\n * @param {object} properties - Properties of the tile engine.\n * @param {number} [properties.tileWidth=32] - Width of a tile.\n * @param {number} [properties.tileHeight=32] - Height of a tile.\n * @param {number} properties.width - Width of the map (in tiles).\n * @param {number} properties.height - Height of the map (in tiles).\n * @param {number} [properties.x=0] - X position to draw.\n * @param {number} [properties.y=0] - Y position to draw.\n * @param {number} [properties.sx=0] - X position to clip the tileset.\n * @param {number} [properties.sy=0] - Y position to clip the tileset.\n * @param {Context} [properties.context=kontra.context] - Provide a context for the tile engine to draw on.\n */\nexport default (properties = {}) => {\n    if (process.env.NODE_ENV === 'development' && (!properties.width || !properties.height)) {\n        throw Error('You must provide width and height properties');\n    }\n\n    const width = properties.width;\n    const height = properties.height;\n\n    // size of the tiles. Most common tile size on opengameart.org seems to be 32x32,\n    // followed by 16x16\n    // Tiled names the property tilewidth and tileheight\n    const tileWidth = properties.tileWidth || 32;\n    const tileHeight = properties.tileHeight || 32;\n\n    const mapWidth = width * tileWidth;\n    const mapHeight = height * tileHeight;\n\n    const context = properties.context || kontra.context;\n    const canvasWidth = context.canvas.width;\n    const canvasHeight = context.canvas.height;\n\n    // create an off-screen canvas for pre-rendering the map\n    // @see http://jsperf.com/render-vs-prerender\n    const offscreenCanvas = document.createElement('canvas');\n    const offscreenContext = offscreenCanvas.getContext('2d');\n\n    // when clipping an image, sx and sy must within the image region, otherwise\n    // Firefox and Safari won't draw it.\n    // @see http://stackoverflow.com/questions/19338032/canvas-indexsizeerror-index-or-size-is-negative-or-greater-than-the-allowed-a\n    const sxMax = Math.max(0, mapWidth - canvasWidth);\n    const syMax = Math.max(0, mapHeight - canvasHeight);\n\n    let _sx, _sy;\n\n    // draw order of layers (by name)\n    const layerOrder = [];\n\n    const tileEngine = {\n        width,\n        height,\n\n        tileWidth,\n        tileHeight,\n\n        mapWidth,\n        mapHeight,\n\n        context,\n\n        x: properties.x || 0,\n        y: properties.y || 0,\n\n        tilesets: [],\n        layers: {},\n\n        /**\n         * Add an tileset for the tile engine to use.\n         * @memberof kontra.tileEngine\n         */\n        addTilesets: function addTilesets(tilesets) {\n            [].concat(tilesets).forEach(tileset => {\n                const tilesetImage = tileset.image;\n                let image, firstGrid, lastTileset, tiles;\n\n                // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n                if (`${tilesetImage}` === tilesetImage) {\n                    let i = Infinity;\n\n                    while (i >= 0) {\n                        i = tilesetImage.lastIndexOf('/', i);\n                        const path = i < 0 ? tilesetImage : tilesetImage.substr(i);\n\n                        if (kontra.assets.images[path]) {\n                            image = kontra.assets.images[path];\n                            break;\n                        }\n\n                        i--;\n                    }\n                } else {\n                    image = tilesetImage;\n                }\n\n                firstGrid = tileset.firstGrid;\n\n                // if the width or height of the provided image is smaller than the tile size,\n                // default calculation to 1\n                const numTiles = ((image.width / tileWidth) | 0 || 1) * ((image.height / tileHeight) | 0 || 1);\n\n                if (!firstGrid) {\n                    // only calculate the first grid if the tile map has a tileset already\n                    if (tileEngine.tilesets.length > 0) {\n                        lastTileset = tileEngine.tilesets[tileEngine.tilesets.length - 1];\n                        tiles =\n                            ((lastTileset.image.width / tileWidth) | 0) * ((lastTileset.image.height / tileHeight) | 0);\n\n                        firstGrid = lastTileset.firstGrid + tiles;\n                    }\n                    // otherwise this is the first tile added to the tile map\n                    else {\n                        firstGrid = 1;\n                    }\n                }\n\n                tileEngine.tilesets.push({\n                    firstGrid,\n                    lastGrid: firstGrid + numTiles - 1,\n                    image\n                });\n\n                // sort the tile map so we can perform a binary search when drawing\n                tileEngine.tilesets.sort((a, b) => a.firstGrid - b.firstGrid);\n            });\n        },\n\n        /**\n         * Add a layer to the tile engine.\n         * @memberof kontra.tileEngine\n         */\n        addLayers: function addLayers(layers) {\n            [].concat(layers).forEach(layer => {\n                // eslint-disable-next-line no-param-reassign\n                layer.render = layer.render === undefined ? true : layer.render;\n\n                let data, row, c, value;\n\n                // flatten a 2D array into a single array\n                if (Array.isArray(layer.data[0])) {\n                    data = [];\n\n                    // eslint-disable-next-line no-cond-assign\n                    for (let r = 0; (row = layer.data[r]); r++) {\n                        for (c = 0; c < width; c++) {\n                            data.push(row[c] || 0);\n                        }\n                    }\n                } else {\n                    data = layer.data;\n                }\n\n                tileEngine.layers[layer.name] = {\n                    data,\n                    zIndex: layer.zIndex || 0,\n                    render: layer.render\n                };\n\n                // merge properties of layer onto layer object\n                for (const prop in layer.properties) {\n                    if (layer.properties.hasOwnProperty(prop)) {\n                        value = layer.properties[prop];\n\n                        try {\n                            value = JSON.parse(value);\n                        } catch (e) {\n                            /* intentionally empty */\n                        }\n\n                        tileEngine.layers[layer.name][prop] = value;\n                    }\n                }\n\n                // only add the layer to the layer order if it should be drawn\n                if (tileEngine.layers[layer.name].render) {\n                    layerOrder.push(layer.name);\n\n                    layerOrder.sort((a, b) => tileEngine.layers[a].zIndex - tileEngine.layers[b].zIndex);\n                }\n            });\n\n            preRenderImage();\n        },\n\n        changeTile(layerId, position, tile) {\n            const dataIndex = getIndex(position);\n            const layer = tileEngine.layers[layerId];\n            layer.data[dataIndex] = tile;\n            renderTile(layer, dataIndex, true);\n        },\n\n        /**\n         * Get the tile from the specified layer at x, y or row, col.\n         * @memberof kontra.tileEngine\n         *\n         * @param {string} name - Name of the layer.\n         * @param {object} position - Position of the tile in either x, y or row, col.\n         * @param {number} position.x - X coordinate of the tile.\n         * @param {number} position.y - Y coordinate of the tile.\n         * @param {number} position.row - Row of the tile.\n         * @param {number} position.col - Col of the tile.\n         *\n         * @returns {number}\n         */\n        tileAtLayer(name, position) {\n            const index = getIndex(position);\n\n            if (index >= 0) {\n                return tileEngine.layers[name].data[index];\n            }\n            return undefined;\n        },\n\n        /**\n         * Render the pre-rendered canvas.\n         * @memberof kontra.tileEngine\n         */\n        render() {\n            tileEngine.context.drawImage(\n                offscreenCanvas,\n                tileEngine.sx,\n                tileEngine.sy,\n                canvasWidth,\n                canvasHeight,\n                tileEngine.x,\n                tileEngine.y,\n                canvasWidth,\n                canvasHeight\n            );\n        },\n\n        /**\n         * Render a specific layer.\n         * @memberof kontra.tileEngine\n         *\n         * @param {string} name - Name of the layer to render.\n         */\n        renderLayer: function renderLayer(name) {\n            const layer = tileEngine.layers[name];\n\n            // calculate the starting tile\n            let row = tileEngine.getRow();\n            const col = tileEngine.getCol();\n            let index = getIndex({ row, col });\n\n            // calculate where to start drawing the tile relative to the drawing canvas\n            const startX = col * tileWidth - tileEngine.sx;\n            const startY = row * tileHeight - tileEngine.sy;\n\n            // calculate how many tiles the drawing canvas can hold\n            const viewWidth = Math.min(Math.ceil(canvasWidth / tileWidth) + 1, width);\n            const viewHeight = Math.min(Math.ceil(canvasHeight / tileHeight) + 1, height);\n            const numTiles = viewWidth * viewHeight;\n\n            let count = 0;\n            let x, y, tile, tileset, image, tileOffset, w, sx, sy;\n\n            // draw just enough of the layer to fit inside the drawing canvas\n            while (count < numTiles) {\n                tile = layer.data[index];\n\n                if (tile) {\n                    tileset = getTileset(tile);\n                    image = tileset.image;\n\n                    x = startX + (count % viewWidth) * tileWidth;\n                    y = startY + ((count / viewWidth) | 0) * tileHeight;\n\n                    tileOffset = tile - tileset.firstGrid;\n                    w = image.width / tileWidth;\n\n                    sx = (tileOffset % w) * tileWidth;\n                    sy = ((tileOffset / w) | 0) * tileHeight;\n\n                    tileEngine.context.drawImage(image, sx, sy, tileWidth, tileHeight, x, y, tileWidth, tileHeight);\n                }\n\n                if (++count % viewWidth === 0) {\n                    index = col + ++row * width;\n                } else {\n                    index++;\n                }\n            }\n        },\n\n        getRowAndCol({ x, y }) {\n            return {\n                row: this.getRow(y),\n                col: this.getCol(x)\n            };\n        },\n\n        getXAndY({ row, col, mapX, mapY }) {\n            return {\n                x: (col ? col * tileWidth : mapX) - tileEngine.sx + tileWidth / 2,\n                y: (row ? row * tileHeight : mapY) - tileEngine.sy + tileHeight / 2\n            };\n        },\n\n        /**\n         * Get the row from the y coordinate.\n         * @memberof kontra.tileEngine\n         *\n         * @param {number} y - Y coordinate.\n         *\n         * @return {number}\n         */\n        getRow(y = 0) {\n            return ((tileEngine.sy + y) / tileHeight) | 0;\n        },\n\n        /**\n         * Get the col from the x coordinate.\n         * @memberof kontra.tileEngine\n         *\n         * @param {number} x - X coordinate.\n         *\n         * @return {number}\n         */\n        getCol(x = 0) {\n            return ((tileEngine.sx + x) / tileWidth) | 0;\n        },\n\n        get sx() {\n            return _sx;\n        },\n\n        get sy() {\n            return _sy;\n        },\n\n        // ensure sx and sy are within the image region\n        set sx(value) {\n            _sx = Math.min(Math.max(0, value), sxMax);\n        },\n\n        set sy(value) {\n            _sy = Math.min(Math.max(0, value), syMax);\n        }\n    };\n\n    // set here so we use setter function\n    tileEngine.sx = properties.sx || 0;\n    tileEngine.sy = properties.sy || 0;\n\n    // make the off-screen canvas the full size of the map\n    offscreenCanvas.width = mapWidth;\n    offscreenCanvas.height = mapHeight;\n\n    // merge properties of the tile engine onto the tile engine itself\n    for (const prop in properties.properties) {\n        if (properties.properties.hasOwnProperty(prop)) {\n            let value = properties.properties[prop];\n\n            try {\n                value = JSON.parse(value);\n            } catch (e) {\n                /* intentionally empty */\n            }\n\n            // passed in properties override properties.properties\n            tileEngine[prop] = tileEngine[prop] || value;\n        }\n    }\n\n    if (properties.tilesets) {\n        tileEngine.addTilesets(properties.tilesets);\n    }\n\n    if (properties.layers) {\n        tileEngine.addLayers(properties.layers);\n    }\n\n    /**\n     * Get the index of the x, y or row, col.\n     * @memberof kontra.tileEngine\n     * @private\n     *\n     * @param {number} position.x - X coordinate of the tile.\n     * @param {number} position.y - Y coordinate of the tile.\n     * @param {number} position.row - Row of the tile.\n     * @param {number} position.col - Col of the tile.\n     *\n     * @return {number} Returns the tile index or -1 if the x, y or row,\n     *         col is outside the dimensions of the tile engine.\n     */\n    function getIndex(position) {\n        let row, col;\n\n        if (typeof position.x !== 'undefined' && typeof position.y !== 'undefined') {\n            row = tileEngine.getRow(position.y);\n            col = tileEngine.getCol(position.x);\n        } else {\n            row = position.row;\n            col = position.col;\n        }\n\n        // don't calculate out of bound numbers\n        if (row < 0 || col < 0 || row >= height || col >= width) {\n            return -1;\n        }\n\n        return col + row * width;\n    }\n\n    /**\n     * Modified binary search that will return the tileset associated with the tile\n     * @memberof kontra.tileEngine\n     * @private\n     *\n     * @param {number} tile - Tile grid.\n     *\n     * @return {object}\n     */\n    function getTileset(tile) {\n        let min = 0;\n        let max = tileEngine.tilesets.length - 1;\n        let index, currTile;\n\n        while (min <= max) {\n            index = ((min + max) / 2) | 0;\n            currTile = tileEngine.tilesets[index];\n\n            if (tile >= currTile.firstGrid && tile <= currTile.lastGrid) {\n                return currTile;\n            } else if (currTile.lastGrid < tile) {\n                min = index + 1;\n            } else {\n                max = index - 1;\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Pre-render the tiles to make drawing fast.\n     * @memberof kontra.tileEngine\n     * @private\n     */\n    function preRenderImage() {\n        // draw each layer in order\n        // eslint-disable-next-line no-cond-assign\n        for (let layerIndex = 0, layer; (layer = tileEngine.layers[layerOrder[layerIndex]]); layerIndex++) {\n            for (let dataIndex = 0, len = layer.data.length; dataIndex < len; dataIndex++) {\n                renderTile(layer, dataIndex);\n            }\n        }\n    }\n\n    function renderTile(layer, dataIndex, clear = false) {\n        const tile = layer.data[dataIndex];\n\n        // skip empty tiles (0)\n        if (!tile) {\n            return;\n        }\n\n        const tileset = getTileset(tile);\n        const image = tileset.image;\n\n        const x = (dataIndex % width) * tileWidth;\n        const y = ((dataIndex / width) | 0) * tileHeight;\n\n        const tileOffset = tile - tileset.firstGrid;\n        const w = image.width / tileWidth;\n\n        const sx = (tileOffset % w) * tileWidth;\n        const sy = ((tileOffset / w) | 0) * tileHeight;\n\n        if (clear) {\n            offscreenContext.clearRect(x, y, tileWidth, tileHeight);\n        }\n        offscreenContext.drawImage(image, sx, sy, tileWidth, tileHeight, x, y, tileWidth, tileHeight);\n    }\n\n    return tileEngine;\n};\n","/* global kontra */\n\nimport {\n    tileHeight,\n    tileWidth,\n    mapHeight as height,\n    mapWidth as width,\n    mapPadding,\n    playerStartCol,\n    playerStartRow\n} from '../config.js';\nimport { calculateCameraCoordinates } from '../utils/index.js';\nimport mapData from './mapData.js';\nimport { addPadding } from './utils/index.js';\nimport { createTilesheet } from './tilesheet/index.js';\nimport { createTileEngine } from '../tileEngine/index.js';\n\nexport default async () => {\n    const { sx, sy } = calculateCameraCoordinates({ col: playerStartCol, row: playerStartRow });\n    const map = createTileEngine({\n        // tile size\n        tileWidth,\n        tileHeight,\n\n        // map size in tiles\n        width: width + mapPadding * 2,\n        height: height + mapPadding * 2,\n\n        sx,\n        sy\n    });\n\n    const paddedMap = addPadding(mapData, width, height, mapPadding);\n    const image = await createTilesheet();\n    map.addTilesets({ image });\n    // map.addTilesets({ image: kontra.assets.images.tilesheet });\n    map.addLayers([\n        {\n            name: 'main',\n            data: paddedMap\n        }\n        // {\n        //     name: 'debug',\n        //     data: new Array(paddedMap.length).fill(0)\n        // }\n        // {\n        //     name: 'grid',\n        //     data: new Array(paddedMap.length).fill(8)\n        // }\n    ]);\n    return map;\n};\n","export default (arr, w, h, pad) => {\n    const retVal = [];\n    let idx = 0;\n    for (let row = 0; row < h + pad * 2; row++) {\n        for (let col = 0; col < w + pad * 2; col++) {\n            if (row < pad || row >= pad + h || col < pad || col >= pad + w) {\n                retVal.push(0);\n                continue;\n            }\n            retVal.push(arr[idx++]);\n        }\n    }\n    return retVal;\n};\n","import { tileHeight, tileWidth } from '../../config.js';\nimport { drawCurve, drawStraight, drawTSection, drawCrossing, drawServer, drawTerminus } from './index.js';\n\n// will be removed by tree shaking\nimport drawDebugGrid from './drawDebugGrid.js';\n\nexport default () => {\n    const canvas = document.createElement('canvas');\n    canvas.width = 8 * tileWidth;\n    canvas.height = 8 * tileHeight;\n    const ctx = canvas.getContext('2d');\n    drawCurve({ ctx, row: 1, col: 1, deg: 0 });\n    drawCurve({ ctx, row: 1, col: 2, deg: 90 });\n    drawCurve({ ctx, row: 2, col: 1, deg: 270 });\n    drawCurve({ ctx, row: 2, col: 2, deg: 180 });\n    drawStraight({ ctx, row: 1, col: 3, deg: 0 });\n    drawStraight({ ctx, row: 2, col: 3, deg: 90 });\n    drawTSection({ ctx, row: 1, col: 4, deg: 0 });\n    drawTSection({ ctx, row: 1, col: 5, deg: 90 });\n    drawTSection({ ctx, row: 1, col: 6, deg: 180 });\n    drawTSection({ ctx, row: 2, col: 5, deg: 270 });\n    drawCrossing({ ctx, row: 2, col: 4 });\n    drawTerminus({ ctx, row: 3, col: 1, deg: 0 });\n    drawTerminus({ ctx, row: 3, col: 2, deg: 90 });\n    drawTerminus({ ctx, row: 3, col: 3, deg: 180 });\n    drawTerminus({ ctx, row: 3, col: 4, deg: 270 });\n    drawServer({ ctx, row: 2, col: 6 });\n    drawCurve({ ctx, row: 4, col: 1, deg: 0, broken: true });\n    drawCurve({ ctx, row: 4, col: 2, deg: 90, broken: true });\n    drawCurve({ ctx, row: 5, col: 1, deg: 270, broken: true });\n    drawCurve({ ctx, row: 5, col: 2, deg: 180, broken: true });\n    drawStraight({ ctx, row: 4, col: 3, deg: 0, broken: true });\n    drawStraight({ ctx, row: 5, col: 3, deg: 90, broken: true });\n    drawTSection({ ctx, row: 4, col: 4, deg: 0, broken: true });\n    drawTSection({ ctx, row: 4, col: 5, deg: 90, broken: true });\n    drawTSection({ ctx, row: 4, col: 6, deg: 180, broken: true });\n    drawTSection({ ctx, row: 5, col: 5, deg: 270, broken: true });\n    drawCrossing({ ctx, row: 5, col: 4, broken: true });\n    drawTerminus({ ctx, row: 6, col: 1, deg: 0, broken: true });\n    drawTerminus({ ctx, row: 6, col: 2, deg: 90, broken: true });\n    drawTerminus({ ctx, row: 6, col: 3, deg: 180, broken: true });\n    drawTerminus({ ctx, row: 6, col: 4, deg: 270, broken: true });\n    drawServer({ ctx, row: 5, col: 6, broken: true });\n\n    if (process.env.NODE_ENV === 'development') {\n        drawDebugGrid({ ctx, row: 1, col: 8 });\n    }\n\n    const image = new Image();\n    image.src = canvas.toDataURL('image/png');\n    // document.getElementById('wrapper').appendChild(image);\n    return new Promise(resolve => setTimeout(() => resolve(image), 100));\n};\n","class MessageBox {\n    constructor() {\n        this.timeoutHandler = null;\n        this.div = document.createElement('div');\n        this.div.style.cssText = `\nbackground-color: rgba(0,0,0,0);\nfont-size: 3em;\nfont-weight: bold;\nalign-items: center;\njustify-content: center;\ndisplay: flex;\ncolor: rgba(255,255,255,0);\nposition: absolute;\ntop: 0;\nleft:0;\nwidth: 100vw;\nheight: 100vh;\ntext-align: center;\npointer-events: none;\ntransition: background-color 3s ease-out, color 3s ease-out;\ntext-transform: uppercase;\nfont-family: monospace;\n    `;\n        const wrapper = document.getElementById('wrapper');\n        wrapper.appendChild(this.div);\n    }\n\n    show(message) {\n        clearTimeout(this.timeoutHandler);\n        this.div.style.transition = '3s';\n        this.div.innerHTML = `<div>${message}</div>`;\n        this.div.style.backgroundColor = 'rgba(0,0,0,0.5)';\n        this.div.style.color = 'rgba(255,255,255,1)';\n    }\n\n    flash(message) {\n        clearTimeout(this.timeoutHandler);\n        this.div.style.transition = '0.5s';\n        this.div.innerHTML = `<div>${message}</div>`;\n        this.div.style.color = 'rgba(255,255,255,1)';\n        this.timeoutHandler = setTimeout(() => (this.div.style.color = 'rgba(255,255,255,0)'), 500);\n    }\n}\nexport default new MessageBox();\n","/* global kontra */\n\nimport { drawPlayer, updatePlayer } from './index.js';\nimport { canvasHeight, canvasWidth, playerStartDirection, collisionRadius } from '../config.js';\nimport { pubsub, GAME_OVER, DROP_SHIP } from '../pubsub/index.js';\nimport { collides } from '../utils/index.js';\nimport { messageBox } from '../messageBox/index.js';\n\nexport default map => {\n    const player = {\n        context: kontra.context,\n        x: canvasWidth / 2,\n        y: canvasHeight / 2,\n        collisionRadius,\n        map,\n        infected: false,\n        gameOver: false,\n        direction: playerStartDirection,\n        nextDirection: null,\n        dropBomb: false,\n        scale: 1,\n        dropping: false,\n        bombCoolingDown: false,\n\n        update() {\n            ({\n                nextDirection: this.nextDirection,\n                direction: this.direction,\n                dropBomb: this.dropBomb,\n                scale: this.scale,\n                bombCoolingDown: this.bombCoolingDown\n            } = updatePlayer(this, pubsub, messageBox));\n        },\n\n        render() {\n            drawPlayer(this);\n        },\n\n        infect(virus) {\n            if (collides(virus, this)) {\n                // eslint-disable-next-line no-param-reassign\n                this.infected = true;\n                if (!this.gameOver) {\n                    messageBox.show('player infected<br>game over');\n                    pubsub.publish(GAME_OVER);\n                }\n            }\n        }\n    };\n\n    pubsub.subscribe(GAME_OVER, () => (player.gameOver = true));\n    pubsub.subscribe(DROP_SHIP, () => (player.dropping = true));\n\n    return player;\n};\n","import { lightGreen, darkGreen, lightRed, darkRed } from '../config.js';\nimport { calculateRotation } from '../utils/index.js';\n\nexport default sprite => {\n    const { context: ctx, x, y, direction, infected, scale } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.scale(scale, scale);\n    ctx.rotate(calculateRotation(direction));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = infected ? lightRed : lightGreen;\n    ctx.fillStyle = infected ? darkRed : darkGreen;\n    ctx.beginPath();\n    ctx.moveTo(-15, 25);\n    ctx.lineTo(0, -25);\n    ctx.lineTo(15, 25);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n};\n","import { degreesToRadians } from './index.js';\nimport { N, E, S, W } from '../directions/index.js';\n\nexport default direction => {\n    switch (direction) {\n        case N:\n            return degreesToRadians(0);\n        case E:\n            return degreesToRadians(90);\n        case S:\n            return degreesToRadians(180);\n        case W:\n            return degreesToRadians(270);\n        default:\n            return null;\n    }\n};\n","import { directionIsAllowed, switchDirection } from '../directions/index.js';\nimport { pubsub, DROP_BOMB, DROP_SHIP, GAME_OVER } from '../pubsub/index.js';\nimport { getKey, isInTheMiddle } from './utils/index.js';\nimport { messageBox } from '../messageBox/index.js';\nimport { bombCooldown } from '../config.js';\n\nexport default sprite => {\n    let { nextDirection, direction, dropBomb, scale, bombCoolingDown } = sprite;\n    const { dropping, map, gameOver, x, y } = sprite;\n    if (dropping) {\n        if (scale > 0) {\n            scale -= 0.01;\n        } else {\n            messageBox.show('You fell into the abyss<br>Game over');\n            pubsub.publish(GAME_OVER);\n        }\n        return { direction, nextDirection, dropBomb, scale, bombCoolingDown };\n    }\n    if (!gameOver) {\n        ({ nextDirection, dropBomb } = getKey(sprite));\n        if (bombCoolingDown) {\n            dropBomb = false;\n        }\n    }\n    if (!isInTheMiddle({ x: map.sx, y: map.sy })) {\n        return { direction, nextDirection, dropBomb, scale, bombCoolingDown };\n    }\n    if (nextDirection && directionIsAllowed(map, { x, y }, nextDirection)) {\n        direction = nextDirection;\n        nextDirection = null;\n    } else {\n        try {\n            direction = switchDirection(map, { x, y }, direction);\n        } catch ({ message }) {\n            if (message === 'dropped') {\n                pubsub.publish(DROP_SHIP);\n            }\n        }\n    }\n    if (dropBomb) {\n        pubsub.publish(DROP_BOMB, map.getRowAndCol({ x, y }));\n        dropBomb = false;\n        bombCoolingDown = true;\n        setTimeout(() => {\n            // eslint-disable-next-line no-param-reassign\n            sprite.bombCoolingDown = false;\n        }, bombCooldown);\n    }\n    return { direction, nextDirection, dropBomb, scale, bombCoolingDown };\n};\n","/* global kontra */\n\nimport { N, E, S, W } from '../../directions/index.js';\n\nexport default sprite => {\n    let { nextDirection, dropBomb } = sprite;\n    if (kontra.keys.pressed('right')) {\n        nextDirection = E;\n    }\n    if (kontra.keys.pressed('left')) {\n        nextDirection = W;\n    }\n    if (kontra.keys.pressed('up')) {\n        nextDirection = N;\n    }\n    if (kontra.keys.pressed('down')) {\n        nextDirection = S;\n    }\n    if (kontra.keys.pressed('space')) {\n        dropBomb = true;\n    }\n    return { nextDirection, dropBomb };\n};\n","import { tileHeight, tileWidth } from '../../config.js';\n\nexport default ({ x, y }) => (x - tileWidth / 2) % tileWidth === 0 && (y - tileHeight / 2) % tileHeight === 0;\n","export default (predecessors, end) => {\n    const nodes = [];\n    let u = end;\n\n    while (u !== undefined) {\n        nodes.push(u);\n        u = predecessors.get(u);\n    }\n\n    nodes.reverse();\n    return nodes;\n};\n","import { findPaths, extractShortest } from './index.js';\n\nexport default (graph, nodes) => {\n    let start = nodes.shift();\n    const path = [];\n    let end, predecessors, shortest;\n\n    while (nodes.length) {\n        end = nodes.shift();\n        predecessors = findPaths(graph, start, end);\n\n        if (predecessors) {\n            shortest = extractShortest(predecessors, end);\n            if (nodes.length) {\n                path.push.apply(path, shortest.slice(0, -1));\n            } else {\n                return path.concat(shortest);\n            }\n        } else {\n            return null;\n        }\n\n        start = end;\n    }\n    return null;\n};\n","export default (data, start, end) => {\n    const costs = new Map([[start, 0]]);\n    const open = new Map([[0, [start]]]);\n    const predecessors = new Map();\n\n    function addToOpen(cost, vertex) {\n        let vertices = open.get(cost);\n        if (!vertices) {\n            vertices = [];\n            open.set(cost, vertices);\n        }\n        vertices.push(vertex);\n    }\n\n    while (open.size > 0) {\n        const currentCost = Array.from(open.keys()).sort((a, b) => a - b)[0];\n\n        const bucket = open.get(currentCost);\n        const node = bucket.shift();\n        const adjacentNodes = data.get(node) || new Map();\n\n        if (bucket.length === 0) {\n            open.delete(currentCost);\n        }\n\n        for (const [vertex, cost] of adjacentNodes) {\n            const totalCost = cost + currentCost;\n            const vertexCost = costs.get(vertex);\n\n            if (vertexCost === undefined || vertexCost > totalCost) {\n                costs.set(vertex, totalCost);\n                addToOpen(totalCost, vertex);\n                predecessors.set(vertex, node);\n            }\n        }\n    }\n\n    return costs.get(end) === undefined ? null : predecessors;\n};\n","import { getNodeByCoords, initGraphAndAllowed } from './index.js';\nimport { N, S, W, E } from '../../directions/index.js';\n\nexport default ({ width, layers }, layer) => {\n    const { graph, allowed } = initGraphAndAllowed(layers[layer].data, width);\n    for (const [node, adjacent] of graph) {\n        const currAllowed = allowed.get(node);\n        const { row, col } = node;\n        let target;\n        for (const dir of currAllowed) {\n            switch (dir) {\n                case N:\n                    target = getNodeByCoords(graph, { row: row - 1, col });\n                    if (target) {\n                        adjacent.set(target, 1);\n                    }\n                    break;\n                case E:\n                    target = getNodeByCoords(graph, { row, col: col + 1 });\n                    if (target) {\n                        adjacent.set(target, 1);\n                    }\n                    break;\n                case S:\n                    target = getNodeByCoords(graph, { row: row + 1, col });\n                    if (target) {\n                        adjacent.set(target, 1);\n                    }\n                    break;\n                case W:\n                    target = getNodeByCoords(graph, { row, col: col - 1 });\n                    if (target) {\n                        adjacent.set(target, 1);\n                    }\n                    break;\n                default:\n            }\n        }\n    }\n    return graph;\n};\n","export default (graph, { row, col }) => {\n    for (const [node] of graph) {\n        if (row === node.row && col === node.col) {\n            return node;\n        }\n    }\n    return null;\n};\n","import { directionSwitchMap } from '../../directions/index.js';\nimport { isValidTile } from '../../utils/index.js';\n\nexport default (layerData, width) => {\n    const graph = new Map();\n    const allowed = new Map();\n    let row = 0;\n    let col = 0;\n    let index = 0;\n    for (const tile of layerData) {\n        if (isValidTile(tile)) {\n            const node = { row, col };\n            allowed.set(node, directionSwitchMap[tile].allowed);\n            graph.set(node, new Map());\n        }\n        if (++index % width === 0) {\n            row++;\n            col = 0;\n        } else {\n            col++;\n        }\n    }\n    return { graph, allowed };\n};\n","import { findShortestPath, convertMapToGraph, getNodeByCoords } from './utils/index.js';\n\nexport class Pathfinder {\n    constructor(graph = null) {\n        this.graph = graph;\n    }\n\n    setDataFromMap(map, layer) {\n        this.graph = convertMapToGraph(map, layer);\n    }\n\n    getNodeByCoords(coords) {\n        return getNodeByCoords(this.graph, coords);\n    }\n\n    findShortestPath(...args) {\n        if (process.env.NODE_ENV === 'development' && !this.graph) {\n            throw new Error('You forgot to set a graph for the pathfinder before trying to use it to find a path');\n        }\n        return findShortestPath(this.graph, args);\n    }\n\n    isReachable(a, b) {\n        const shortestPath = this.findShortestPathByCoords(a, b);\n        return shortestPath !== null;\n    }\n\n    findShortestPathByCoords(...args) {\n        return this.findShortestPath(...args.map(coords => this.getNodeByCoords(coords)));\n    }\n}\n\nexport default new Pathfinder();\n","/* global kontra */\n\nimport { drawUser, INFECTED } from './index.js';\nimport { tileWidth, tileHeight, collisionRadius } from '../config.js';\nimport { ONLINE } from './index.js';\nimport { pubsub, INFECTED as INFECTED_EVENT } from '../pubsub/index.js';\n\nexport default ({ map, row, col }) => {\n    const { x, y } = map.getXAndY({ row, col });\n    return {\n        context: kontra.context,\n        x,\n        y,\n        collisionRadius,\n        infected: false,\n        map,\n        mapX: col * tileWidth,\n        mapY: row * tileHeight,\n        row,\n        col,\n        status: ONLINE,\n        update() {\n            ({ x: this.x, y: this.y } = map.getXAndY({ mapX: this.mapX, mapY: this.mapY }));\n        },\n        render() {\n            drawUser(this);\n        },\n        infect() {\n            this.status = INFECTED;\n            pubsub.publish(INFECTED_EVENT);\n        }\n    };\n};\n","export const ONLINE = 0;\nexport const OFFLINE = 1;\nexport const INFECTED = 2;\n","/* global kontra */\nimport { lightBlue, darkBlue, lightGreen, darkGreen, lightRed, darkRed } from '../config.js';\nimport { ONLINE, OFFLINE, INFECTED } from './constants.js';\nimport { degreesToRadians as deg2rad } from '../utils/index.js';\n\nconst spriteMapping = {\n    [ONLINE]: { fg: lightBlue, bg: darkBlue },\n    [OFFLINE]: { fg: lightGreen, bg: darkGreen },\n    [INFECTED]: { fg: lightRed, bg: darkRed }\n};\n\nexport default sprite => {\n    const { context: ctx, x, y, status } = sprite;\n    const { fg, bg } = spriteMapping[status];\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = fg;\n    ctx.fillStyle = bg;\n    ctx.beginPath();\n    ctx.moveTo(-40, 40);\n    ctx.lineTo(-40, 20);\n    ctx.arc(-20, 20, 20, deg2rad(180), deg2rad(270));\n    ctx.moveTo(-20, 0);\n    ctx.lineTo(20, 0);\n    ctx.arc(20, 20, 20, deg2rad(270), deg2rad(0));\n    ctx.lineTo(40, 40);\n    ctx.lineTo(-40, 40);\n    ctx.moveTo(-23, 20);\n    ctx.lineTo(-23, 40);\n    ctx.moveTo(23, 20);\n    ctx.lineTo(23, 40);\n    ctx.fill();\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(0, -15, 25, deg2rad(0), deg2rad(360));\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n};\n","/* global kontra */\n\nimport {\n    virusStartDirection,\n    virusStartCol,\n    virusStartRow,\n    tileWidth,\n    tileHeight,\n    collisionRadius\n} from '../config.js';\nimport { drawVirus, updateVirus, Blips } from './index.js';\n\nexport default map => {\n    const { x, y } = map.getXAndY({ row: virusStartRow, col: virusStartCol });\n    const blips = new Blips();\n    const virus = {\n        context: kontra.context,\n        x,\n        y,\n        collisionRadius,\n        map,\n        mapX: virusStartCol * tileWidth,\n        mapY: virusStartRow * tileHeight,\n        direction: virusStartDirection,\n        blips,\n        update() {\n            ({ x: this.x, y: this.y, mapX: this.mapX, mapY: this.mapY, direction: this.direction } = updateVirus(this));\n            this.blips.update();\n        },\n        render() {\n            drawVirus(this);\n            this.blips.render();\n        }\n    };\n    blips.start(virus);\n\n    return virus;\n};\n","import {\n    switchDirection,\n    isIntersection,\n    directionSwitchMap,\n    getOppositeDirection,\n    directionIsAllowed\n} from '../directions/index.js';\nimport { getRandomInt } from '../utils/index.js';\nimport { isInTheMiddle, moveVirus, getBestDirection } from './utils/index.js';\n\nlet visits = null;\n\nexport default sprite => {\n    let { direction } = sprite;\n    const { map } = sprite;\n    const { mapX, mapY } = moveVirus(sprite);\n    const { x, y } = map.getXAndY({ mapX, mapY });\n    if (!visits) {\n        visits = Array(map.height)\n            .fill()\n            .map(() => Array(map.width).fill(0));\n    }\n    if (isInTheMiddle({ mapX, mapY })) {\n        const tile = map.tileAtLayer('main', { x, y });\n        const { col, row } = map.getRowAndCol({ x, y });\n        visits[row][col]++;\n        if (isIntersection(tile)) {\n            const { allowed } = directionSwitchMap[tile];\n            const viable = allowed.filter(\n                dir => dir !== getOppositeDirection(direction) && directionIsAllowed(map, { x, y }, dir)\n            );\n            const bestDirections = getBestDirection({ viable, visits, row, col });\n            direction = bestDirections[getRandomInt(0, bestDirections.length - 1)];\n        } else {\n            direction = switchDirection(map, { x, y }, direction);\n        }\n    }\n    return {\n        direction,\n        mapY,\n        mapX,\n        x,\n        y\n    };\n};\n","import { N, E, S, W } from '../../directions/index.js';\nimport { virusSpeed } from '../../config.js';\n\nexport default ({ mapX, mapY, direction }) => {\n    switch (direction) {\n        case N:\n            return { mapX, mapY: mapY - virusSpeed };\n        case E:\n            return { mapX: mapX + virusSpeed, mapY };\n        case S:\n            return { mapX, mapY: mapY + virusSpeed };\n        case W:\n            return { mapX: mapX - virusSpeed, mapY };\n        default:\n            return { mapX, mapY };\n    }\n};\n","import { tileHeight, tileWidth } from '../../config.js';\n\nexport default ({ mapX, mapY }) => mapX % tileWidth === 0 && mapY % tileHeight === 0;\n","import { N, E, S, W } from '../../directions/index.js';\n\nexport default ({ viable, visits, row, col }) => {\n    let minVis = Number.MAX_SAFE_INTEGER;\n    return viable\n        .map(dir => {\n            let vis;\n            switch (dir) {\n                case N:\n                    vis = visits[row - 1][col];\n                    break;\n                case E:\n                    vis = visits[row][col + 1];\n                    break;\n                case S:\n                    vis = visits[row + 1][col];\n                    break;\n                case W:\n                    vis = visits[row][col - 1];\n                    break;\n                default:\n            }\n            minVis = vis < minVis ? vis : minVis;\n            return { dir, vis };\n        })\n        .filter(({ vis }) => vis === minVis)\n        .map(({ dir }) => dir);\n};\n","import { N, E, S, W } from './index.js';\n\nexport default direction => {\n    switch (direction) {\n        case N:\n            return S;\n        case E:\n            return W;\n        case S:\n            return N;\n        case W:\n            return W;\n        default:\n            return null;\n    }\n};\n","import { lightRed, darkRed } from '../config.js';\nimport { getRandomInt as ri } from '../utils/index.js';\n\nexport default sprite => {\n    const { context: ctx, x, y } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightRed;\n    ctx.fillStyle = darkRed;\n    ctx.beginPath();\n    ctx.moveTo(ri(-5, 5), ri(-5, -25)); // 1\n    ctx.lineTo(ri(5, 50), ri(-5, -50)); // 2\n    ctx.lineTo(ri(5, 25), ri(-5, 5)); // 3\n    ctx.lineTo(ri(5, 50), ri(5, 50)); // 4\n    ctx.lineTo(ri(-5, 5), ri(5, 25)); // 5\n    ctx.lineTo(ri(-5, -50), ri(5, 50)); // 6\n    ctx.lineTo(ri(-5, -25), ri(-5, 5)); // 7\n    ctx.lineTo(ri(-5, -50), ri(-5, -50)); // 8\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.restore();\n};\n","/* global kontra */\n\nimport { tileHeight, virusBlipTtl } from '../config.js';\nimport { drawBlip } from './index.js';\n\nexport default ({ x, y }) => ({\n    context: kontra.context,\n    x,\n    y,\n    ttl: virusBlipTtl,\n    radius: tileHeight,\n    update() {\n        this.radius += 10;\n        this.ttl--;\n    },\n    render() {\n        drawBlip(this);\n    }\n});\n","import { lightRed } from '../config.js';\nimport { degreesToRadians as deg2rad } from '../utils/index.js';\n\nexport default sprite => {\n    const { context: ctx, x, y, radius } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = lightRed;\n    ctx.beginPath();\n    ctx.arc(0, 0, radius, deg2rad(0), deg2rad(360));\n    ctx.closePath();\n    ctx.stroke();\n\n    ctx.restore();\n};\n","import { virusBlipInterval } from '../config.js';\nimport { createBlip } from './index.js';\n\nexport default class {\n    constructor() {\n        this.blips = [];\n    }\n\n    start(virus) {\n        setInterval(() => {\n            this.blips.push(createBlip({ x: virus.x, y: virus.y }));\n        }, virusBlipInterval);\n    }\n    update() {\n        this.blips.forEach(blip => blip.update());\n        this.blips = this.blips.filter(blip => blip.ttl > 0);\n    }\n    render() {\n        this.blips.forEach(blip => blip.render());\n    }\n}\n","/* global kontra */\n\nimport { collisionRadius, tileHeight, tileWidth } from '../config.js';\nimport { drawBomb, updateBomb } from './index.js';\nimport { FUSE_BURNING } from './index.js';\n\nexport default (map, { row, col }) => {\n    const { x, y } = map.getXAndY({ row, col });\n    return {\n        context: kontra.context,\n        x,\n        y,\n        collisionRadius,\n        fuseLength: 100,\n        status: FUSE_BURNING,\n        shrapnel: [],\n        explosionDuration: 0,\n        map,\n        mapX: col * tileWidth,\n        mapY: row * tileHeight,\n        row,\n        col,\n        update() {\n            ({\n                status: this.status,\n                fuseLength: this.fuseLength,\n                explosionDuration: this.explosionDuration,\n                x: this.x,\n                y: this.y\n            } = updateBomb(this));\n        },\n        render() {\n            drawBomb(this);\n        }\n    };\n};\n","export const FUSE_BURNING = 0;\nexport const EXPLODING = 1;\nexport const EXPLODED = 2;\n","import { EXPLODING, FUSE_BURNING } from './constants.js';\nimport { drawBombWithFuse } from './index.js';\n\nexport default sprite => {\n    const { status, shrapnel } = sprite;\n    switch (status) {\n        case FUSE_BURNING:\n            drawBombWithFuse(sprite);\n            break;\n        case EXPLODING:\n            shrapnel.forEach(s => s.render());\n            break;\n        default:\n    }\n};\n","import { lightRed, lightBlue, darkBlue } from '../config.js';\nimport { getRandomInt as ri } from '../utils/index.js';\nimport { degreesToRadians as deg2rad } from '../utils/index.js';\n\nexport default sprite => {\n    const { context: ctx, x, y, fuseLength } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(deg2rad(-45));\n\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.fillStyle = darkBlue;\n\n    /* bomb */\n    ctx.beginPath();\n    ctx.moveTo(23, -10);\n    ctx.lineTo(40, -10);\n    ctx.lineTo(40, 10);\n    ctx.lineTo(23, 10);\n    ctx.arc(0, 0, 25, deg2rad(19), deg2rad(341));\n    ctx.fill();\n    ctx.stroke();\n\n    /* fuse */\n    const fuseRad = 25; // radius of the fuse arc\n    const fuseDeg = (fuseLength / 100) * 90; // length of the fuse arc in degrees\n    ctx.beginPath();\n    ctx.moveTo(40, 0);\n    ctx.arc(40, 25, fuseRad, deg2rad(270), deg2rad(270 + fuseDeg));\n    ctx.stroke();\n\n    /* sparks */\n    const sparkCX = Math.cos(deg2rad(fuseDeg - 90)) * fuseRad + 40; // X-coord of sparks center\n    const sparkCY = Math.sin(deg2rad(fuseDeg - 90)) * fuseRad + 25; // Y-coord of sparks centers\n    const sparkRad = 15; // radius of the sparks circle\n    ctx.fillStyle = lightRed;\n    for (let i = 0; i < 10; i++) {\n        const sparkX = Math.cos(deg2rad(ri(0, 360))) * ri(0, sparkRad) + sparkCX;\n        const sparkY = Math.sin(deg2rad(ri(0, 360))) * ri(0, sparkRad) + sparkCY;\n        ctx.fillRect(sparkX - 1, sparkY - 1, 3, 3);\n    }\n\n    ctx.restore();\n};\n","/* global kontra */\n\nimport { FUSE_BURNING, EXPLODING, EXPLODED } from './index.js';\nimport { createShrapnel } from './index.js';\nimport { pubsub, MAP_CHANGED, USERS_POSSIBLY_OFFLINE, BOMB_EXPLODES } from '../pubsub/index.js';\n\nexport default sprite => {\n    let { status, fuseLength, explosionDuration, x, y } = sprite;\n    const { shrapnel, map, mapX, mapY, row, col } = sprite;\n\n    ({ x, y } = map.getXAndY({ mapX, mapY }));\n    switch (status) {\n        case FUSE_BURNING:\n            fuseLength -= 1;\n            if (fuseLength < 0) {\n                status = EXPLODING;\n                pubsub.publish(BOMB_EXPLODES);\n                for (let i = 0; i < 50; i++) {\n                    shrapnel.push(createShrapnel({ x, y }));\n                }\n                const tile = map.tileAtLayer('main', { row, col });\n                map.changeTile('main', { row, col }, tile + 24);\n                pubsub.publish(MAP_CHANGED, map);\n                pubsub.publish(USERS_POSSIBLY_OFFLINE);\n            }\n            break;\n        case EXPLODING:\n            shrapnel.forEach(s => s.update());\n            explosionDuration++;\n            if (explosionDuration === 200) {\n                status = EXPLODED;\n            }\n            break;\n        default:\n    }\n    return {\n        status,\n        fuseLength,\n        explosionDuration,\n        x,\n        y\n    };\n};\n","/* global kontra */\nimport { getRandomInt as ri } from '../utils/index.js';\nimport { degreesToRadians as deg2rad } from '../utils/index.js';\nimport { drawShrapnel } from './index.js';\n\nexport default ({ x, y }) => {\n    const dir = ri(0, 360);\n    const speed = ri(5, 15);\n    return {\n        context: kontra.context,\n        x,\n        y,\n        dx: Math.cos(deg2rad(dir)) * speed,\n        dy: Math.sin(deg2rad(dir)) * speed,\n        rotation: ri(0, 360),\n        rotationDir: [ri(-10, -1), ri(1, 10)][ri(0, 1)],\n        update() {\n            this.x += this.dx;\n            this.y += this.dy;\n            this.rotation += this.rotationDir;\n        },\n        render() {\n            drawShrapnel(this);\n        }\n    };\n};\n","import { lightBlue, darkBlue } from '../config.js';\nimport { degreesToRadians as deg2rad } from '../utils/index.js';\n\nexport default sprite => {\n    const { context: ctx, x, y, rotation } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(deg2rad(rotation));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.fillStyle = darkBlue;\n    ctx.beginPath();\n    ctx.moveTo(0, -10);\n    ctx.lineTo(10, 5);\n    ctx.lineTo(-10, 5);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n};\n","/**\n * SfxrParams\n *\n * Copyright 2010 Thomas Vian\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author Thomas Vian\n */\nfunction SfxrParams() {\n    //--------------------------------------------------------------------------\n    //\n    //  Settings String Methods\n    //\n    //--------------------------------------------------------------------------\n\n    /**\n     * Parses a settings array into the parameters\n     * @param array Array of the settings values, where elements 0 - 23 are\n     *                a: waveType\n     *                b: attackTime\n     *                c: sustainTime\n     *                d: sustainPunch\n     *                e: decayTime\n     *                f: startFrequency\n     *                g: minFrequency\n     *                h: slide\n     *                i: deltaSlide\n     *                j: vibratoDepth\n     *                k: vibratoSpeed\n     *                l: changeAmount\n     *                m: changeSpeed\n     *                n: squareDuty\n     *                o: dutySweep\n     *                p: repeatSpeed\n     *                q: phaserOffset\n     *                r: phaserSweep\n     *                s: lpFilterCutoff\n     *                t: lpFilterCutoffSweep\n     *                u: lpFilterResonance\n     *                v: hpFilterCutoff\n     *                w: hpFilterCutoffSweep\n     *                x: masterVolume\n     * @return If the string successfully parsed\n     */\n    this.setSettings = function(values) {\n        for (let i = 0; i < 24; i++) {\n            this[String.fromCharCode(97 + i)] = values[i] || 0;\n        }\n\n        // I moved this here from the reset(true) function\n        if (this.c < 0.01) {\n            this.c = 0.01;\n        }\n\n        const totalTime = this.b + this.c + this.e;\n        if (totalTime < 0.18) {\n            const multiplier = 0.18 / totalTime;\n            this.b *= multiplier;\n            this.c *= multiplier;\n            this.e *= multiplier;\n        }\n    };\n}\n\n/**\n * SfxrSynth\n *\n * Copyright 2010 Thomas Vian\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author Thomas Vian\n */\nfunction SfxrSynth() {\n    // All variables are kept alive through function closures\n\n    //--------------------------------------------------------------------------\n    //\n    //  Sound Parameters\n    //\n    //--------------------------------------------------------------------------\n\n    this._params = new SfxrParams(); // Params instance\n\n    //--------------------------------------------------------------------------\n    //\n    //  Synth Variables\n    //\n    //--------------------------------------------------------------------------\n\n    let _envelopeLength0, // Length of the attack stage\n        _envelopeLength1, // Length of the sustain stage\n        _envelopeLength2, // Length of the decay stage\n        _period, // Period of the wave\n        _maxPeriod, // Maximum period before sound stops (from minFrequency)\n        _slide, // Note slide\n        _deltaSlide, // Change in slide\n        _changeAmount, // Amount to change the note by\n        _changeTime, // Counter for the note change\n        _changeLimit, // Once the time reaches this limit, the note changes\n        _squareDuty, // Offset of center switching point in the square wave\n        _dutySweep; // Amount to change the duty by\n\n    //--------------------------------------------------------------------------\n    //\n    //  Synth Methods\n    //\n    //--------------------------------------------------------------------------\n\n    /**\n     * Resets the runing variables from the params\n     * Used once at the start (total reset) and for the repeat effect (partial reset)\n     */\n    this.reset = function() {\n        // Shorter reference\n        const p = this._params;\n\n        _period = 100 / (p.f * p.f + 0.001);\n        _maxPeriod = 100 / (p.g * p.g + 0.001);\n\n        _slide = 1 - p.h * p.h * p.h * 0.01;\n        _deltaSlide = -p.i * p.i * p.i * 0.000001;\n\n        if (!p.a) {\n            _squareDuty = 0.5 - p.n / 2;\n            _dutySweep = -p.o * 0.00005;\n        }\n\n        _changeAmount = p.l > 0 ? 1 - p.l * p.l * 0.9 : 1 + p.l * p.l * 10;\n        _changeTime = 0;\n        _changeLimit = p.m == 1 ? 0 : (1 - p.m) * (1 - p.m) * 20000 + 32;\n    };\n\n    // I split the reset() function into two functions for better readability\n    this.totalReset = function() {\n        this.reset();\n\n        // Shorter reference\n        const p = this._params;\n\n        // Calculating the length is all that remained here, everything else moved somewhere\n        _envelopeLength0 = p.b * p.b * 100000;\n        _envelopeLength1 = p.c * p.c * 100000;\n        _envelopeLength2 = p.e * p.e * 100000 + 10;\n        // Full length of the volume envelop (and therefore sound)\n        return (_envelopeLength0 + _envelopeLength1 + _envelopeLength2) | 0;\n    };\n\n    /**\n     * Writes the wave to the supplied buffer ByteArray\n     * @param buffer A ByteArray to write the wave to\n     * @return If the wave is finished\n     */\n    this.synthWave = function(buffer, length) {\n        // Shorter reference\n        const p = this._params;\n\n        // If the filters are active\n        const _filters = p.s != 1 || p.v;\n\n        // Cutoff multiplier which adjusts the amount the wave position can move\n\n        let _hpFilterCutoff = p.v * p.v * 0.1;\n\n        // Speed of the high-pass cutoff multiplier\n\n        const _hpFilterDeltaCutoff = 1 + p.w * 0.0003;\n\n        // Cutoff multiplier which adjusts the amount the wave position can move\n\n        let _lpFilterCutoff = p.s * p.s * p.s * 0.1;\n\n        // Speed of the low-pass cutoff multiplier\n\n        const _lpFilterDeltaCutoff = 1 + p.t * 0.0001;\n\n        // If the low pass filter is active\n\n        const _lpFilterOn = p.s != 1;\n\n        // masterVolume * masterVolume (for quick calculations)\n\n        const _masterVolume = p.x * p.x;\n\n        // Minimum frequency before stopping\n\n        const _minFreqency = p.g;\n\n        // If the phaser is active\n\n        const _phaser = p.q || p.r;\n\n        // Change in phase offset\n\n        const _phaserDeltaOffset = p.r * p.r * p.r * 0.2;\n\n        // Phase offset for phaser effect\n\n        let _phaserOffset = p.q * p.q * (p.q < 0 ? -1020 : 1020);\n\n        // Once the time reaches this limit, some of the    iables are reset\n\n        const _repeatLimit = p.p ? (((1 - p.p) * (1 - p.p) * 20000) | 0) + 32 : 0;\n\n        // The punch factor (louder at begining of sustain)\n\n        const _sustainPunch = p.d;\n\n        // Amount to change the period of the wave by at the peak of the vibrato wave\n\n        const _vibratoAmplitude = p.j / 2;\n\n        // Speed at which the vibrato phase moves\n\n        const _vibratoSpeed = p.k * p.k * 0.01;\n\n        // The type of wave to generate\n\n        const _waveType = p.a;\n\n        let _envelopeLength = _envelopeLength0;\n        // Length of the current envelope stage\n\n        const _envelopeOverLength0 = 1 / _envelopeLength0;\n        // (for quick calculations)\n\n        const _envelopeOverLength1 = 1 / _envelopeLength1;\n        // (for quick calculations)\n\n        const _envelopeOverLength2 = 1 / _envelopeLength2; // (for quick calculations)\n\n        // Damping muliplier which restricts how fast the wave position can move\n        let _lpFilterDamping = (5 / (1 + p.u * p.u * 20)) * (0.01 + _lpFilterCutoff);\n        if (_lpFilterDamping > 0.8) {\n            _lpFilterDamping = 0.8;\n        }\n        _lpFilterDamping = 1 - _lpFilterDamping;\n\n        let _finished = false;\n        // If the sound has finished\n\n        let _envelopeStage = 0;\n        // Current stage of the envelope (attack, sustain, decay, end)\n\n        let _envelopeTime = 0;\n        // Current time through current enelope stage\n\n        let _envelopeVolume = 0;\n        // Current volume of the envelope\n\n        let _hpFilterPos = 0;\n        // Adjusted wave position after high-pass filter\n\n        let _lpFilterDeltaPos = 0;\n        // Change in low-pass wave position, as allowed by the cutoff and damping\n\n        let _lpFilterOldPos,\n\n\n        // Previous low-pass wave position\n\n         \n _lpFilterPos = 0;\n\n\n\n        // Adjusted wave position after low-pass filter\n\n         \n \nlet _periodTemp,\n\n\n        // Period modified by vibrato\n\n         _phase = 0;\n\n\n        // Phase through the wave\n\n         \nlet _phaserInt;\n\n        // Integer phaser offset, for bit maths\n\n        let _phaserPos = 0;\n\n        // Position through the phaser buffer\n\n        let _pos,\n\n\n\n        // Phase expresed as a Number from 0-1, used for fast sin approx\n\n         \n \n \n _repeatTime = 0;\n\n\n\n\n // Counter for the repeats\n            \n \n \n \n \nvar _sample;\n\n\n\n\n // Sub-sample calculated 8 times per actual sample, averaged out to get the super sample\n            \n \n \n \n \nvar _superSample;\n        // Actual sample writen to the wave\n\n        let _vibratoPhase = 0; // Phase through the vibrato sine wave\n\n        // Buffer of wave values used to create the out of phase second wave\n        const _phaserBuffer = new Array(1024);\n\n        // Buffer of random values used to generate noise\n\n        const _noiseBuffer = new Array(32);\n        for (var i = _phaserBuffer.length; i--; ) {\n            _phaserBuffer[i] = 0;\n        }\n        for (var i = _noiseBuffer.length; i--; ) {\n            _noiseBuffer[i] = Math.random() * 2 - 1;\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (_finished) {\n                return i;\n            }\n\n            // Repeats every _repeatLimit times, partially resetting the sound parameters\n            if (_repeatLimit) {\n                if (++_repeatTime >= _repeatLimit) {\n                    _repeatTime = 0;\n                    this.reset();\n                }\n            }\n\n            // If _changeLimit is reached, shifts the pitch\n            if (_changeLimit) {\n                if (++_changeTime >= _changeLimit) {\n                    _changeLimit = 0;\n                    _period *= _changeAmount;\n                }\n            }\n\n            // Acccelerate and apply slide\n            _slide += _deltaSlide;\n            _period *= _slide;\n\n            // Checks for frequency getting too low, and stops the sound if a minFrequency was set\n            if (_period > _maxPeriod) {\n                _period = _maxPeriod;\n                if (_minFreqency > 0) {\n                    _finished = true;\n                }\n            }\n\n            _periodTemp = _period;\n\n            // Applies the vibrato effect\n            if (_vibratoAmplitude > 0) {\n                _vibratoPhase += _vibratoSpeed;\n                _periodTemp *= 1 + Math.sin(_vibratoPhase) * _vibratoAmplitude;\n            }\n\n            _periodTemp |= 0;\n            if (_periodTemp < 8) {\n                _periodTemp = 8;\n            }\n\n            // Sweeps the square duty\n            if (!_waveType) {\n                _squareDuty += _dutySweep;\n                if (_squareDuty < 0) {\n                    _squareDuty = 0;\n                } else if (_squareDuty > 0.5) {\n                    _squareDuty = 0.5;\n                }\n            }\n\n            // Moves through the different stages of the volume envelope\n            if (++_envelopeTime > _envelopeLength) {\n                _envelopeTime = 0;\n\n                switch (++_envelopeStage) {\n                    case 1:\n                        _envelopeLength = _envelopeLength1;\n                        break;\n                    case 2:\n                        _envelopeLength = _envelopeLength2;\n                }\n            }\n\n            // Sets the volume based on the position in the envelope\n            switch (_envelopeStage) {\n                case 0:\n                    _envelopeVolume = _envelopeTime * _envelopeOverLength0;\n                    break;\n                case 1:\n                    _envelopeVolume = 1 + (1 - _envelopeTime * _envelopeOverLength1) * 2 * _sustainPunch;\n                    break;\n                case 2:\n                    _envelopeVolume = 1 - _envelopeTime * _envelopeOverLength2;\n                    break;\n                case 3:\n                    _envelopeVolume = 0;\n                    _finished = true;\n            }\n\n            // Moves the phaser offset\n            if (_phaser) {\n                _phaserOffset += _phaserDeltaOffset;\n                _phaserInt = _phaserOffset | 0;\n                if (_phaserInt < 0) {\n                    _phaserInt = -_phaserInt;\n                } else if (_phaserInt > 1023) {\n                    _phaserInt = 1023;\n                }\n            }\n\n            // Moves the high-pass filter cutoff\n            if (_filters && _hpFilterDeltaCutoff) {\n                _hpFilterCutoff *= _hpFilterDeltaCutoff;\n                if (_hpFilterCutoff < 0.00001) {\n                    _hpFilterCutoff = 0.00001;\n                } else if (_hpFilterCutoff > 0.1) {\n                    _hpFilterCutoff = 0.1;\n                }\n            }\n\n            _superSample = 0;\n            for (let j = 8; j--; ) {\n                // Cycles through the period\n                _phase++;\n                if (_phase >= _periodTemp) {\n                    _phase %= _periodTemp;\n\n                    // Generates new random noise for this period\n                    if (_waveType == 3) {\n                        for (let n = _noiseBuffer.length; n--; ) {\n                            _noiseBuffer[n] = Math.random() * 2 - 1;\n                        }\n                    }\n                }\n\n                // Gets the sample from the oscillator\n                switch (_waveType) {\n                    case 0: // Square wave\n                        _sample = _phase / _periodTemp < _squareDuty ? 0.5 : -0.5;\n                        break;\n                    case 1: // Saw wave\n                        _sample = 1 - (_phase / _periodTemp) * 2;\n                        break;\n                    case 2: // Sine wave (fast and accurate approx)\n                        _pos = _phase / _periodTemp;\n                        _pos = _pos > 0.5 ? (_pos - 1) * 6.28318531 : _pos * 6.28318531;\n                        _sample =\n                            _pos < 0\n                                ? 1.27323954 * _pos + 0.405284735 * _pos * _pos\n                                : 1.27323954 * _pos - 0.405284735 * _pos * _pos;\n                        _sample =\n                            _sample < 0\n                                ? 0.225 * (_sample * -_sample - _sample) + _sample\n                                : 0.225 * (_sample * _sample - _sample) + _sample;\n                        break;\n                    case 3: // Noise\n                        _sample = _noiseBuffer[Math.abs(((_phase * 32) / _periodTemp) | 0)];\n                }\n\n                // Applies the low and high pass filters\n                if (_filters) {\n                    _lpFilterOldPos = _lpFilterPos;\n                    _lpFilterCutoff *= _lpFilterDeltaCutoff;\n                    if (_lpFilterCutoff < 0) {\n                        _lpFilterCutoff = 0;\n                    } else if (_lpFilterCutoff > 0.1) {\n                        _lpFilterCutoff = 0.1;\n                    }\n\n                    if (_lpFilterOn) {\n                        _lpFilterDeltaPos += (_sample - _lpFilterPos) * _lpFilterCutoff;\n                        _lpFilterDeltaPos *= _lpFilterDamping;\n                    } else {\n                        _lpFilterPos = _sample;\n                        _lpFilterDeltaPos = 0;\n                    }\n\n                    _lpFilterPos += _lpFilterDeltaPos;\n\n                    _hpFilterPos += _lpFilterPos - _lpFilterOldPos;\n                    _hpFilterPos *= 1 - _hpFilterCutoff;\n                    _sample = _hpFilterPos;\n                }\n\n                // Applies the phaser effect\n                if (_phaser) {\n                    _phaserBuffer[_phaserPos % 1024] = _sample;\n                    _sample += _phaserBuffer[(_phaserPos - _phaserInt + 1024) % 1024];\n                    _phaserPos++;\n                }\n\n                _superSample += _sample;\n            }\n\n            // Averages out the super samples and applies volumes\n            _superSample *= 0.125 * _envelopeVolume * _masterVolume;\n\n            // Clipping if too loud\n            buffer[i] = _superSample >= 1 ? 32767 : _superSample <= -1 ? -32768 : (_superSample * 32767) | 0;\n        }\n\n        return length;\n    };\n}\n\n// Adapted from http://codebase.es/riffwave/\nconst synth = new SfxrSynth();\n// Export for the Closure Compiler\nexport default function(settings) {\n    // Initialize SfxrParams\n    synth._params.setSettings(settings);\n    // Synthesize Wave\n    const envelopeFullLength = synth.totalReset();\n    const data = new Uint8Array((((envelopeFullLength + 1) / 2) | 0) * 4 + 44);\n    let used = synth.synthWave(new Uint16Array(data.buffer, 44), envelopeFullLength) * 2;\n    const dv = new Uint32Array(data.buffer, 0, 44);\n    // Initialize header\n    dv[0] = 0x46464952; // \"RIFF\"\n    dv[1] = used + 36; // put total size here\n    dv[2] = 0x45564157; // \"WAVE\"\n    dv[3] = 0x20746d66; // \"fmt \"\n    dv[4] = 0x00000010; // size of the following\n    dv[5] = 0x00010001; // Mono: 1 channel, PCM format\n    dv[6] = 0x0000ac44; // 44,100 samples per second\n    dv[7] = 0x00015888; // byte rate: two bytes per sample\n    dv[8] = 0x00100002; // 16 bits per sample, aligned on every two bytes\n    dv[9] = 0x61746164; // \"data\"\n    dv[10] = used; // put number of samples here\n\n    // Base64 encoding written by me, @maettig\n    used += 44;\n    let i = 0;\n\n    const base64Characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    let output = 'data:audio/wav;base64,';\n    for (; i < used; i += 3) {\n        const a = (data[i] << 16) | (data[i + 1] << 8) | data[i + 2];\n        output +=\n            base64Characters[a >> 18] +\n            base64Characters[(a >> 12) & 63] +\n            base64Characters[(a >> 6) & 63] +\n            base64Characters[a & 63];\n    }\n    i -= used;\n    return output.slice(0, output.length - i) + '=='.slice(0, i);\n}\n","import jsfxr from '../../vendor/sfxr.js';\nimport generateSounds from './sounds.js';\n\nexport default function ArcadeAudio() {\n    this.sounds = {};\n    generateSounds(this);\n}\n\nArcadeAudio.prototype.add = function(key, count, settings) {\n    this.sounds[key] = [];\n    settings.forEach(function(elem, index) {\n        this.sounds[key].push({\n            tick: 0,\n            count,\n            pool: []\n        });\n        for (let i = 0; i < count; i++) {\n            const audio = new Audio();\n            audio.src = jsfxr(elem);\n            this.sounds[key][index].pool.push(audio);\n        }\n    }, this);\n};\n\nArcadeAudio.prototype.play = function(key) {\n    const sound = this.sounds[key];\n    const soundData = sound.length > 1 ? sound[Math.floor(Math.random() * sound.length)] : sound[0];\n    soundData.pool[soundData.tick].play();\n    if (soundData.tick < soundData.count - 1) {\n        soundData.tick++;\n    } else {\n        soundData.tick = 0;\n    }\n};\n","/* eslint-disable no-sparse-arrays */\nexport default function generateSounds(aa) {\n    aa.add('infected', 3, [\n        [2, , 0.2916, , 0.2587, 0.9356, 0.3909, -0.2493, , , , , , 0.3583, 0.1617, , , , 1, , , 0.1217, , 0.5]\n    ]);\n\n    aa.add('drop-bomb', 3, [[0, , 0.0641, 0.5296, 0.1228, 0.4195, , , , , , 0.3029, 0.6261, , , , , , 1, , , , , 0.5]]);\n\n    aa.add('drop-ship', 1, [\n        [0, , 0.57, , 0.1398, 0.61, , -0.26, 0.1, , , 0.02, , 0.3325, , , , , 0.9793, , , , , 0.5]\n    ]);\n\n    aa.add('explode', 3, [\n        [3, , 0.1606, 0.5988, 0.2957, 0.1157, , -0.3921, , , , , , , , , 0.3225, -0.2522, 1, , , , , 0.25]\n    ]);\n}\n/* eslint-enable no-alert, no-console */\n","import { pubsub, DROP_BOMB, BOMB_EXPLODES, INFECTED, DROP_SHIP } from '../pubsub/index.js';\nimport ArcadeAudio from './ArcadeAudio.js';\n\nconst aa = new ArcadeAudio();\n\nexport function initAudio() {\n    pubsub.subscribe(DROP_BOMB, () => aa.play('drop-bomb'));\n    pubsub.subscribe(DROP_BOMB, () => console.log('drop bomb'));\n    pubsub.subscribe(BOMB_EXPLODES, () => aa.play('explode'));\n    pubsub.subscribe(INFECTED, () => aa.play('infected'));\n    pubsub.subscribe(DROP_SHIP, () => aa.play('drop-ship'));\n\n    /*\n   * GENERATE NEW SOUNDS ON http://www.superflashbros.net/as3sfxr/\n   * CMD + C copies the values\n   *\n   * */\n}\n","/* global kontra */\n\nimport { createCanvas } from './canvas/index.js';\nimport { createLoop } from './loop/index.js';\nimport { createMap } from './map/index.js';\nimport { createPlayer } from './player/index.js';\nimport { Users } from './user/index.js';\nimport { createVirus } from './virus/index.js';\nimport { Bombs } from './bomb/index.js';\nimport { initPathfinder } from './pathfinder/index.js';\nimport { pubsub, USERS_POSSIBLY_OFFLINE } from './pubsub/index.js';\nimport { initAudio } from './audio/index.js';\n\n// will be removed by tree shaking\nimport createDevbox from './devbox/createDevbox.js';\nif (process.env.NODE_ENV === 'development') {\n    createDevbox();\n}\n\n(async () => {\n    createCanvas();\n    kontra.init();\n    const map = await createMap();\n    initPathfinder(map);\n    const player = createPlayer(map);\n    const virus = createVirus(map);\n    const bombs = new Bombs(map);\n    const users = new Users(map);\n    pubsub.subscribe(USERS_POSSIBLY_OFFLINE, () => users.updateOnlineStatus(virus));\n    const loop = createLoop({ map, player, virus, users, bombs });\n    initAudio();\n    loop.start();\n})();\n","import { canvasHeight, canvasWidth, lightBlue } from '../config.js';\n\nexport default () => {\n    const canvas = document.createElement('canvas');\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvas.style.cssText = `\n        border: 4px solid ${lightBlue};\n    `;\n    const wrapper = document.getElementById('wrapper');\n    wrapper.appendChild(canvas);\n};\n","import { pathfinder } from './index.js';\nimport { pubsub, MAP_CHANGED } from '../pubsub/index.js';\n\nexport default map => {\n    pathfinder.setDataFromMap(map, 'main');\n    pubsub.subscribe(MAP_CHANGED, changedMap => pathfinder.setDataFromMap(changedMap, 'main'));\n};\n","import { pubsub, DROP_BOMB, BOMB_EXPLODES } from '../pubsub/index.js';\nimport { EXPLODED } from './constants.js';\nimport { createBomb } from './index.js';\n\nexport default class {\n    constructor(map) {\n        this.map = map;\n        this.bombs = [];\n        pubsub.subscribe(DROP_BOMB, mapCoords => this.dropBomb(mapCoords));\n    }\n    dropBomb(mapCoords) {\n        if (\n            this.bombs.length > 0 &&\n            this.bombs.find(({ col, row }) => col === mapCoords.col && row === mapCoords.row)\n        ) {\n            // don't drop a bomb where there already is one waiting to explode\n            return;\n        }\n        this.bombs.push(createBomb(this.map, mapCoords));\n    }\n    update() {\n        this.bombs = this.bombs.filter(bomb => {\n            bomb.update();\n            return bomb.status !== EXPLODED;\n        });\n    }\n    render() {\n        this.bombs.forEach(bomb => bomb.render());\n    }\n}\n","import { ONLINE, OFFLINE } from './index.js';\nimport { createUser, INFECTED } from './index.js';\nimport { multiCollides } from '../utils/index.js';\nimport { pubsub, GAME_OVER } from '../pubsub/index.js';\nimport { messageBox } from '../messageBox/index.js';\nimport { pathfinder } from '../pathfinder/index.js';\n\nexport default class {\n    constructor(map) {\n        this.map = map;\n        this.users = [];\n        this.gameOver = false;\n        for (let row = 0; row < map.height; row++) {\n            for (let col = 0; col < map.width; col++) {\n                const tile = map.tileAtLayer('main', { row, col });\n                if (tile >= 17 && tile <= 20) {\n                    this.users.push(createUser({ map, row, col }));\n                }\n            }\n        }\n        pubsub.subscribe(GAME_OVER, () => (this.gameOver = true));\n    }\n\n    updateOnlineStatus(...viruses) {\n        const virusesWithRowAndCol = viruses.map(virus => ({\n            ...virus,\n            ...this.map.getRowAndCol({ x: virus.x, y: virus.y })\n        }));\n        let goneOffline = 0;\n        for (const user of this.users.filter(({ status }) => status === ONLINE)) {\n            for (const virus of virusesWithRowAndCol) {\n                const isReachable = pathfinder.isReachable(user, virus);\n                if (!isReachable) {\n                    goneOffline++;\n                    user.status = OFFLINE;\n                }\n            }\n        }\n        if (goneOffline > 0) {\n            const { online, offline, infected } = this.getStats();\n            if (online === 0) {\n                messageBox.show(`level completed<br>offline users: ${offline}<br>infected users: ${infected}`);\n                pubsub.publish(GAME_OVER);\n            } else {\n                messageBox.flash(`${offline} users went offline<br>good job!`);\n            }\n        }\n    }\n\n    getStats() {\n        return this.users.reduce(\n            (acc, { status }) => ({\n                online: acc.online + (status === ONLINE ? 1 : 0),\n                offline: acc.offline + (status === OFFLINE ? 1 : 0),\n                infected: acc.infected + (status === INFECTED ? 1 : 0)\n            }),\n            { online: 0, offline: 0, infected: 0 }\n        );\n    }\n\n    update() {\n        this.users.forEach(user => user.update());\n    }\n\n    render() {\n        this.users.forEach(user => user.render());\n    }\n\n    infect(...viruses) {\n        const { users, gameOver } = this;\n        const userVirusCollisions = multiCollides(users, viruses).filter(([user]) => user.status !== INFECTED);\n        if (userVirusCollisions.length === 0) {\n            return;\n        }\n        userVirusCollisions.forEach(([user]) => user.infect());\n        if (gameOver) {\n            return;\n        }\n        const { online, offline, infected } = this.getStats();\n        if (online === 0) {\n            messageBox.show(`level completed<br>offline users: ${offline}<br>infected users: ${infected}`);\n            pubsub.publish(GAME_OVER);\n            return;\n        }\n        messageBox.flash('user infected!');\n    }\n}\n","import { collides } from './index.js';\n\nexport default (arr1, arr2) => {\n    const collisions = [];\n    for (let i1 = 0; i1 < arr1.length; i1++) {\n        const sprite1 = arr1[i1];\n        for (let i2 = 0; i2 < arr2.length; i2++) {\n            const sprite2 = arr2[i2];\n            if (collides(sprite1, sprite2)) {\n                collisions.push([sprite1, sprite2]);\n            }\n        }\n    }\n    return collisions;\n};\n"],"sourceRoot":""}
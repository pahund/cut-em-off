{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/directions/constants.js","webpack:///./src/directions/directionIsAllowed.js","webpack:///./src/utils/degreesToRadians.js","webpack:///./src/utils/getRandomInt.js","webpack:///./src/utils/transformMapCoordinates.js","webpack:///./src/utils/collides.js","webpack:///./src/directions/switchDirection.js","webpack:///./src/directions/directionSwitchMap.js","webpack:///./src/directions/isIntersection.js","webpack:///./src/directions/getNextTile.js","webpack:///./src/directions/isValidTile.js","webpack:///./src/config.js","webpack:///./src/pubsub/pubsub.js","webpack:///./src/pubsub/constants.js","webpack:///./src/loop/createLoop.js","webpack:///./src/loop/utils/moveCamera.js","webpack:///./src/map/mapData.js","webpack:///./src/map/tilesheet/drawCurve.js","webpack:///./src/map/tilesheet/utils/krakel.js","webpack:///./src/map/tilesheet/drawStraight.js","webpack:///./src/map/tilesheet/drawTSection.js","webpack:///./src/map/tilesheet/drawCrossing.js","webpack:///./src/map/tilesheet/drawServer.js","webpack:///./src/map/tilesheet/drawTerminus.js","webpack:///./src/tileEngine/createTileEngine.js","webpack:///./src/tileEngine/utils/flatIndex.js","webpack:///./src/map/createMap.js","webpack:///./src/utils/calculateCameraCoordinates.js","webpack:///./src/map/utils/addPadding.js","webpack:///./src/map/tilesheet/createTilesheet.js","webpack:///./src/messageBox/messageBox.js","webpack:///./src/player/createPlayer.js","webpack:///./src/player/drawPlayer.js","webpack:///./src/utils/calculateRotation.js","webpack:///./src/player/updatePlayer.js","webpack:///./src/player/utils/getKey.js","webpack:///./src/player/utils/isInTheMiddle.js","webpack:///./src/utils/calculateRowAndCol.js","webpack:///./src/user/utils/allInfected.js","webpack:///./src/user/createUser.js","webpack:///./src/user/constants.js","webpack:///./src/user/drawUser.js","webpack:///./src/virus/createVirus.js","webpack:///./src/virus/updateVirus.js","webpack:///./src/virus/utils/moveVirus.js","webpack:///./src/virus/utils/isInTheMiddle.js","webpack:///./src/virus/utils/getBestDirections.js","webpack:///./src/directions/getOppositeDirection.js","webpack:///./src/virus/drawVirus.js","webpack:///./src/virus/createBlip.js","webpack:///./src/virus/drawBlip.js","webpack:///./src/virus/Blips.js","webpack:///./src/bomb/createBomb.js","webpack:///./src/bomb/constants.js","webpack:///./src/bomb/drawBomb.js","webpack:///./src/bomb/drawBombWithFuse.js","webpack:///./src/bomb/updateBomb.js","webpack:///./src/bomb/createShrapnel.js","webpack:///./src/bomb/drawShrapnel.js","webpack:///./vendor/riffwave.js","webpack:///./vendor/sfxr.js","webpack:///./src/audio/index.js","webpack:///./src/index.js","webpack:///./src/canvas/createCanvas.js","webpack:///./src/bomb/Bombs.js","webpack:///./src/user/Users.js","webpack:///./src/utils/multiCollides.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","N","E","S","W","directionIsAllowed","map","x","y","direction","tile","tileAtLayer","isValidTile","directionSwitchMap","allowed","includes","nextTile","getNextTile","degreesToRadians","degrees","Math","PI","getRandomInt","a","b","min","max","floor","random","transformMapCoordinates","row","col","tileWidth","tileHeight","sx","sy","undefined","config_canvasWidth","config_canvasHeight","collides","sprite1","sprite2","dx","dy","sqrt","collisionRadius","switchDirection","curr","Error","nextDirection","change","otherDirections","filter","dir","length","1","[object Object]","2","3","4","5","6","9","10","11","12","13","14","17","18","19","20","38","intersectionTiles","entries","push","Number","config_tileWidth","config_tileHeight","pubsub","this","subscribers","message","callback","incomingMessage","payload","forEach","GAME_OVER","DROP_BOMB","BOMB_EXPLODES","INFECTED","createLoop","player","virus","users","bombs","shipMoving","subscribe","kontra","gameLoop","update","infect","moveCamera","render","mapData","calculatePointOnArc","deg","cos","sin","drawCurve","ctx","broken","save","translate","rotate","lineWidth","strokeStyle","beginPath","moveTo","arc","lineTo","stroke","restore","krakel","data","draw","drawStraight","drawTSection","drawCrossing","drawServer","drawTerminus","createTileEngine","properties","width","height","mapWidth","mapHeight","context","canvasWidth","canvas","canvasHeight","offscreenCanvas","document","createElement","offscreenContext","getContext","sxMax","syMax","_sx","_sy","layerOrder","tileEngine","tilesets","layers","addTilesets","concat","tileset","tilesetImage","image","firstGrid","lastTileset","tiles","Infinity","path","lastIndexOf","substr","assets","images","numTiles","lastGrid","sort","addLayers","layer","Array","isArray","zIndex","prop","JSON","parse","e","layerIndex","dataIndex","len","renderTile","preRenderImage","layerId","flatIndex","layerCollidesWith","getRow","getCol","endRow","endCol","index","getIndex","position","drawImage","renderLayer","startX","startY","viewWidth","ceil","tileOffset","w","count","getTileset","_layerOrder","currTile","clear","clearRect","createMap","calculateCameraCoordinates","config_mapWidth","config_mapHeight","paddedMap","arr","h","retVal","idx","addPadding","Image","src","toDataURL","Promise","resolve","setTimeout","createTilesheet","fill","messageBox","timeoutHandler","div","style","cssText","getElementById","appendChild","clearTimeout","transition","innerHTML","backgroundColor","color","createPlayer","sprite","infected","gameOver","dropBomb","scale","dropping","bombCoolingDown","updatePlayer","drawPlayer","show","publish","calculateRotation","fillStyle","closePath","keys","pressed","getKey","isInTheMiddle","calculateRowAndCol","mapX","mapY","status","drawUser","spriteMapping","0","fg","bg","createVirus","blips","Blips","updateVirus","drawVirus","start","updateVirus_visits","moveVirus","utils_isInTheMiddle","isIntersection","bestDirections","viable","visits","minVis","MAX_SAFE_INTEGER","vis","getBestDirections","getOppositeDirection","createBlip","ttl","radius","drawBlip","setInterval","blip","createBomb","fuseLength","FUSE_BURNING","shrapnel","explosionDuration","updateBomb","drawBomb","drawBombWithFuse","fuseDeg","sparkCX","sparkCY","sparkX","sparkY","fillRect","createShrapnel","changeTile","speed","rotation","rotationDir","advance","drawShrapnel","FastBase64","chars","encLookup","Init","Encode","dst","n1","n2","n3","riffwave","u32ToArray","u16ToArray","wav","dataURI","header","chunkId","chunkSize","format","subChunk1Id","subChunk1Size","audioFormat","numChannels","sampleRate","byteRate","blockAlign","bitsPerSample","subChunk2Id","subChunk2Size","Make","SQUARE","sqr","pow","Params","oldParams","wave_type","p_env_attack","p_env_sustain","p_env_punch","p_env_decay","p_base_freq","p_freq_limit","p_freq_ramp","p_freq_dramp","p_vib_strength","p_vib_speed","p_arp_mod","p_arp_speed","p_duty","p_duty_ramp","p_repeat_speed","p_pha_offset","p_pha_ramp","p_lpf_freq","p_lpf_ramp","p_lpf_resonance","p_hpf_freq","p_hpf_ramp","sound_vol","sample_rate","sample_size","frnd","range","rnd","SoundEffect","ps","initFromUI","explosion","hitHurt","jump","mutate","p_vib_delay","initForRepeat","elapsedSinceRepeat","period","periodMax","enableFrequencyCutoff","periodMult","periodMultSlide","dutyCycle","dutyCycleSlide","arpeggioMultiplier","arpeggioTime","waveShape","parseInt","fltw","enableLowPassFilter","fltw_d","fltdmp","flthp","flthp_d","vibratoSpeed","vibratoAmplitude","envelopeLength","envelopePunch","flangerOffset","flangerOffsetSlide","repeatTime","gain","exp","bitsPerChannel","generate","fltp","fltdp","fltphp","noise_buffer","envelopeStage","envelopeElapsed","vibratoPhase","phase","ipp","flanger_buffer","num_clipped","buffer","sample_sum","num_summed","summands","rfperiod","env_vol","iperiod","envf","iphase","abs","sample","si","sub_sample","fp","pp","wave","clipping","sfxr","audio_SoundEffect","audio_Params","sounds","fx","PARAMS","audio","Audio","SOUND","createCanvas","init","mapCoords","find","bomb","createUser","user","viruses","userVirusCollisions","arr1","arr2","collisions","i1","i2","multiCollides","every","state","allInfected","flash","loop","console","log","play"],"mappings":"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AX,EAAAY,WC5CAM,EAAA,EAAiBlB,MAAAhF,MAAAC,MAAAgF,UAAA,MACjBD,EAAAE,OACAF,EAAAG,WAAAlF,EAAA,GAAA8C,IAAA,GAAA/C,EAAA,GAAAgD,IAAA,GACAgC,EAAAK,UAAA,EACAL,EAAAM,YVsBA,UUrBAN,EAAAO,YAEAM,EAAAb,EADAC,IAEA,WACA,WACA,WACA,SACA,UACA,UACA,UACA,UACA,UACA,UACA,WACA,WACA,WACA,WACA,WACA,WACA,UACA,YACA,YACA,YACA,YACA,YACA,YACA,UACA,WACA,WACA,aAIA,YACA,YACA,YACA,WACA,WACA,WACA,WACA,WACA,WACA,UACA,UACA,WAGAD,EAAAW,SACAX,EAAAY,WCrDAO,EAAA,EAAiBnB,MAAAhF,MAAAC,MAAAgF,aACjBD,EAAAE,OACAF,EAAAG,WAAAlF,EAAA,GAAA8C,IAAA,GAAA/C,EAAA,GAAAgD,IAAA,GACAgC,EAAAK,UAAA,EACAL,EAAAM,YXsBA,UWrBAN,EAAAO,YACAM,EAAAb,IACA,WACA,WACA,UACA,UACA,WACA,WACA,YACA,YACA,YAEAA,EAAAW,SACAV,IACAD,EAAAK,UAAA,EACAQ,EAAAb,IACA,WACA,UACA,WACA,WACA,WACA,WACA,YACA,WACA,WACA,SACA,SACA,SACA,UACA,SACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WACA,WACA,SACA,UACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,UACA,UACA,YACA,UACA,WACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,aAEAA,EAAAW,UAEAX,EAAAY,WCzEAQ,EAAA,EAAiBpB,MAAAhF,MAAAC,MAAA2E,MAAAK,UAAA,MACjBD,EAAAE,OACAF,EAAAG,WAAAlF,EAAA,GAAA8C,IAAA,GAAA/C,EAAA,GAAAgD,IAAA,GACAgC,EAAAI,OAAAhG,EAAAwF,IACAI,EAAAK,UAAA,EACAL,EAAAM,YZoBA,UYnBAN,EAAAO,YAEAM,EAAAb,EADAC,IACA,0EAEA,yCAEAD,EAAAW,SACAX,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","file":"game.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export const N = 'N';\nexport const E = 'E';\nexport const S = 'S';\nexport const W = 'W';\n","import { directionSwitchMap, getNextTile, isValidTile } from '.';\n\nexport default (map, { x, y }, direction) => {\n    const tile = map.tileAtLayer('main', { x, y });\n    if (!isValidTile(tile) || !directionSwitchMap[tile].allowed.includes(direction)) {\n        return false;\n    }\n    const nextTile = getNextTile(map, { x, y }, direction);\n    return isValidTile(nextTile);\n};\n","export default degrees => (degrees * Math.PI) / 180;\n","export default (a, b) => {\n    const min = Math.min(a, b);\n    const max = Math.max(a, b);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n","import { canvasHeight, canvasWidth } from '../config';\n\n/**\n * Transforms coordinates relative to the map (either row/col or x/y)\n * to coordinates on the canvas.\n *\n * @param map The map to calculate the coordinates from\n * @param row The row on the map (use either this or y)\n * @param col The column on the map (use either this x)\n * @param x The X coordinate on the map (use either this or col)\n * @param y The Y coordinate on the map (use either this or row)\n * @return {{x: number, y: number}}\n */\nexport default (map, { row, col, x, y }) => {\n    const { tileWidth, tileHeight, sx, sy } = map;\n    const calcX = x !== undefined ? x : (col - 1) * tileWidth;\n    const calcY = y !== undefined ? y : (row - 1) * tileHeight;\n    const nextX = calcX - sx + canvasWidth / 2 + tileWidth / 2;\n    const nextY = calcY - sy + canvasHeight / 2 + tileHeight / 2;\n    return { x: nextX, y: nextY };\n};\n","export default (sprite1, sprite2) => {\n    const dx = sprite1.x - sprite2.x;\n    const dy = sprite1.y - sprite2.y;\n    return Math.sqrt(dx * dx + dy * dy) < sprite1.collisionRadius + sprite2.collisionRadius;\n};\n","import { directionSwitchMap, directionIsAllowed, isValidTile } from '.';\nimport { getRandomInt } from '../utils';\n\nexport default (map, { x, y }, curr) => {\n    const tile = map.tileAtLayer('main', { x, y });\n    /* player accidentally stepped onto a broken conduit tile */\n    if (!isValidTile(tile)) {\n        throw new Error('dropped');\n    }\n    const nextDirection = directionSwitchMap[tile].change[curr] || curr;\n    if (directionIsAllowed(map, { x, y }, nextDirection)) {\n        return nextDirection;\n    }\n    const otherDirections = directionSwitchMap[tile].allowed.filter(dir => directionIsAllowed(map, { x, y }, dir));\n    switch (otherDirections.length) {\n        case 0:\n            /* oh no, player locked themselves in! */\n            throw new Error('locked in');\n        case 1:\n            return otherDirections[0];\n        default:\n            return otherDirections[getRandomInt(0, otherDirections.length - 1)];\n    }\n};\n","import { N, E, S, W } from '.';\n\nexport default {\n    // curve from S to E\n    1: {\n        allowed: [S, E],\n        change: {\n            [N]: E,\n            [W]: S\n        }\n    },\n    // curve from W to S\n    2: {\n        allowed: [W, S],\n        change: {\n            [N]: W,\n            [E]: S\n        }\n    },\n    // straight from N to S\n    3: {\n        allowed: [N, S],\n        change: {}\n    },\n    // T section W, N, E\n    4: {\n        allowed: [W, N, E],\n        change: {\n            [S]: N\n        }\n    },\n    // T section N, E, S\n    5: {\n        allowed: [N, E, S],\n        change: {\n            [W]: E\n        }\n    },\n    // T section W, E, S\n    6: {\n        allowed: [W, E, S],\n        change: {\n            [N]: S\n        }\n    },\n    // curve from N to E\n    9: {\n        allowed: [N, E],\n        change: {\n            [S]: E,\n            [W]: N\n        }\n    },\n    // curve from W to N\n    10: {\n        allowed: [W, N],\n        change: {\n            [E]: N,\n            [S]: W\n        }\n    },\n    // straight from W to E\n    11: {\n        allowed: [W, E],\n        change: {}\n    },\n    // crossing\n    12: {\n        allowed: [N, E, S, W],\n        change: {}\n    },\n    // T section N, S, W\n    13: {\n        allowed: [N, S, W],\n        change: {\n            [E]: W\n        }\n    },\n    // server\n    14: {\n        allowed: [N, S],\n        change: {}\n    },\n    // terminus S\n    17: {\n        allowed: [S],\n        change: {\n            [N]: S\n        }\n    },\n    // terminus W\n    18: {\n        allowed: [W],\n        change: {\n            [E]: W\n        }\n    },\n    // terminus N\n    19: {\n        allowed: [N],\n        change: {\n            [S]: N\n        }\n    },\n    // terminus E\n    20: {\n        allowed: [E],\n        change: {\n            [W]: E\n        }\n    },\n    // broken server\n    38: {\n        allowed: [N, S],\n        change: {}\n    }\n};\n","import { directionSwitchMap } from './index';\n\nconst intersectionTiles = [];\nfor (const [tile, { allowed }] of Object.entries(directionSwitchMap)) {\n    if (allowed.length > 2) {\n        intersectionTiles.push(Number(tile));\n    }\n}\n\nexport default tile => intersectionTiles.includes(tile);\n","import { N, E, S, W } from '.';\nimport { tileHeight, tileWidth } from '../config';\n\nexport default (map, { x, y }, direction) =>\n    map.tileAtLayer('main', {\n        x: direction === E ? x + tileWidth : direction === W ? x - tileWidth : x,\n        y: direction === N ? y - tileHeight : direction === S ? y + tileHeight : y\n    });\n","export default tile => tile < 25 || (tile > 30 && tile < 33) || (tile > 37 && tile < 41) || tile > 44;\n","import { N, W } from './directions';\n\nexport const canvasWidth = 800;\nexport const canvasHeight = 600;\n\n/* map */\nexport const tileWidth = 100;\nexport const tileHeight = 100;\nexport const mapWidth = 20;\nexport const mapHeight = 20;\nexport const mapPaddingX = 4;\nexport const mapPaddingY = 3;\n\n/* player */\nexport const playerStartCol = 5;\nexport const playerStartRow = 6;\nexport const playerStartDirection = N;\nexport const playerSpeed = 5;\n\n/* virus */\nexport const virusStartCol = 5;\nexport const virusStartRow = 4;\nexport const virusStartDirection = W;\nexport const virusSpeed = 2.5;\nexport const virusBlipInterval = 1000;\nexport const virusBlipTtl = 180;\n\n/* colors */\nexport const lightGreen = '#75a042';\nexport const darkGreen = '#365b1d';\nexport const lightBlue = '#52638a';\nexport const darkBlue = '#2b3653';\nexport const lightRed = '#cd3926';\nexport const darkRed = '#7a2431';\n\nexport const collisionRadius = 30;\nexport const bombCooldown = 100;\n","// exported for testing\nexport class Pubsub {\n    constructor() {\n        this.subscribers = [];\n    }\n    subscribe(message, callback) {\n        this.subscribers.push({ message, callback });\n    }\n    publish(incomingMessage, payload) {\n        this.subscribers.forEach(({ message, callback }) => message === incomingMessage && callback(payload));\n    }\n}\n\nexport default new Pubsub();\n","export const GAME_OVER = 0;\nexport const DROP_BOMB = 1;\nexport const BOMB_EXPLODES = 6;\nexport const INFECTED = 7;\nexport const DROP_SHIP = 2;\n","/* global kontra */\n\nimport { moveCamera } from './utils';\nimport { calculateRowAndCol } from '../utils';\nimport { pubsub, DROP_SHIP } from '../pubsub';\n\nexport default ({ map, player, virus, users, bombs }) => {\n    const times = [];\n    let fps;\n    let shipMoving = true;\n    pubsub.subscribe(DROP_SHIP, () => (shipMoving = false));\n\n    return kontra.gameLoop({\n        update() {\n            virus.update();\n            player.update();\n            player.infect(virus);\n            if (shipMoving) {\n                moveCamera(map, player.direction);\n            }\n            users.update();\n            users.infect([virus]);\n            bombs.update();\n        },\n        render() {\n            map.render();\n            users.render();\n            bombs.render();\n            player.render();\n            virus.render();\n            if (process.env.NODE_ENV === 'development') {\n                const now = performance.now();\n                while (times.length > 0 && times[0] <= now - 1000) {\n                    times.shift();\n                }\n                times.push(now);\n                fps = times.length;\n                const { row, col } = calculateRowAndCol(map);\n\n                // eslint-disable-next-line no-param-reassign\n                window.devbox.innerHTML = `${fps} fps – sx=${map.sx}, sy=${map.sy}, row=${row}, col=${col}`;\n            }\n        }\n    });\n};\n","import { playerSpeed } from '../../config';\nimport { N, E, S, W } from '../../directions';\n\nexport default (map, direction) => {\n    switch (direction) {\n        case N:\n            // eslint-disable-next-line no-param-reassign\n            map.sy -= playerSpeed;\n            break;\n        case E:\n            // eslint-disable-next-line no-param-reassign\n            map.sx += playerSpeed;\n            break;\n        case S:\n            // eslint-disable-next-line no-param-reassign\n            map.sy += playerSpeed;\n            break;\n        case W:\n            // eslint-disable-next-line no-param-reassign\n            map.sx -= playerSpeed;\n            break;\n        default:\n    }\n};\n","// prettier-ignore\nexport default [\n    0, 17,  0,  0,  0, 17,  0,  0,  0, 17,  0,  0,  0, 17,  0,  0,  0, 17,  0,  0,\n   20,  4, 11,  2,  1,  4,  2,  0,  0,  5, 11,  6, 11, 13,  0,  1, 11, 12,  2,  0,\n    0,  1, 11, 10,  9, 11, 13,  0,  0,  3,  0,  3,  0,  5, 11, 13,  0,  3,  3,  0,\n    0,  3,  1, 11,  6, 11, 10,  0,  1,  4,  2,  9, 11, 13,  0,  9, 11, 10,  3,  0,\n    0,  3,  3,  0,  3,  0,  0,  0,  3,  1, 13,  0,  0,  3,  0,  0,  0,  0,  5, 18,\n    0,  3,  3,  0, 14,  0,  1, 11, 10,  3,  9, 11,  6,  4, 11,  6,  2,  0,  3,  0,\n    0,  3,  3,  0,  3,  0,  3,  0,  0,  3,  0,  0,  3,  0,  0,  3,  3,  0,  3,  0,\n    0,  9, 13,  0,  5, 11, 10,  0,  0,  3,  1, 11, 10,  0,  0,  3,  3,  0,  3,  0,\n    0,  0,  3,  0,  3,  0,  0,  0,  1,  4, 10,  0,  0,  0,  0,  3,  5, 11,  4, 18,\n    0,  1, 13,  0,  5, 11,  2,  0,  3,  0,  1, 11, 11, 11, 11, 12, 10,  0,  0,  0,\n    0,  3,  3,  0,  3,  0,  5, 11, 13,  0,  9, 11,  2,  0,  0,  3,  0,  0,  1, 18,\n    0,  9, 10,  0,  5, 11, 10,  0,  9, 11, 11, 11, 12, 11,  6, 10,  0,  0,  3,  0,\n    0,  0,  0,  0,  3,  1, 11,  2,  1, 11, 11, 11, 10,  0,  3,  0,  1, 11,  4, 18,\n   20,  6,  6, 11, 10,  3,  0,  3,  3,  0,  0,  0,  1,  2,  9, 11, 12, 11,  2,  0,\n    0,  3,  3,  0,  0,  3,  0,  3,  3,  1, 11,  2,  3,  3,  0,  0,  3,  0,  3,  0,\n    0,  5,  4,  2,  0,  5, 11, 10,  3,  3,  0,  5, 12,  4, 11, 11, 13,  0,  5, 18,\n    0,  3,  0,  5, 11, 12, 11,  6, 10,  9,  6, 10,  3,  0,  0,  0,  9, 11, 10,  0,\n   20,  4, 11, 13,  0,  3,  0,  9, 11, 11, 13,  0,  9, 11,  6, 11,  6,  6, 11, 18,\n    0,  0,  0,  3,  0,  3,  0,  0,  0,  0,  5, 11, 11,  2,  3,  0,  3,  3,  0,  0,\n    0,  0,  0, 19,  0, 19,  0,  0,  0,  0, 19,  0,  0, 19,  9, 11, 10, 19,  0,  0\n];\n","/* eslint-disable no-param-reassign */\nimport { degreesToRadians as deg2rad } from '../../utils';\nimport { tileHeight, tileWidth, lightBlue } from '../../config';\n\nfunction calculatePointOnArc(deg, r) {\n    return [Math.cos(deg2rad(deg)) * r + 50, Math.sin(deg2rad(deg)) * r + 50];\n}\n\nexport default ({ ctx, row, col, deg, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.rotate(deg2rad(deg));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        ctx.moveTo(20, 50);\n        ctx.arc(50, 50, 30, deg2rad(180), deg2rad(190));\n        ctx.moveTo(...calculatePointOnArc(190, 30));\n        ctx.lineTo(10, 45);\n        ctx.lineTo(10, 35);\n        ctx.lineTo(-10, 40);\n        ctx.lineTo(...calculatePointOnArc(190, 70));\n        ctx.arc(50, 50, 70, deg2rad(190), deg2rad(180), true);\n        ctx.moveTo(50, 20);\n        ctx.arc(50, 50, 30, deg2rad(270), deg2rad(260), true);\n        ctx.moveTo(...calculatePointOnArc(260, 30));\n        ctx.lineTo(40, 10);\n        ctx.lineTo(45, 0);\n        ctx.lineTo(35, 0);\n        ctx.lineTo(...calculatePointOnArc(260, 70));\n        ctx.arc(50, 50, 70, deg2rad(260), deg2rad(270));\n    } else {\n        ctx.moveTo(20, 50);\n        ctx.arc(50, 50, 30, deg2rad(180), deg2rad(270));\n        ctx.moveTo(-20, 50);\n        ctx.arc(50, 50, 70, deg2rad(180), deg2rad(270));\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","/* creates canvas moveTo and lineTo commands from arrays; doing this mostly to save a couple of bytes */\nexport default (ctx, data) => data.forEach(([draw, x, y]) => ctx[draw ? 'lineTo' : 'moveTo'](x, y));\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config';\nimport { degreesToRadians as deg2rad } from '../../utils';\nimport { krakel } from './utils';\n\nexport default ({ ctx, row, col, deg, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.rotate(deg2rad(deg));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        krakel(ctx, [\n            [0, -20, 50],\n            [1, -20, 30],\n            [1, -10, 40],\n            [1, 0, 25],\n            [1, 10, 35],\n            [1, 20, 30],\n            [1, 20, 50],\n            [0, -20, -50],\n            [1, -20, -40],\n            [1, -10, -25],\n            [1, 0, -35],\n            [1, 10, -30],\n            [1, 20, -40],\n            [1, 20, -50]\n        ]);\n    } else {\n        krakel(ctx, [[0, -20, -50], [1, -20, 50], [0, 20, -50], [1, 20, 50]]);\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config';\nimport { degreesToRadians as deg2rad } from '../../utils';\nimport { krakel } from './utils';\n\nexport default ({ ctx, row, col, deg, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.rotate(deg2rad(deg));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        krakel(ctx, [\n            [0, 50, 20],\n            [1, 40, 20],\n            [1, 45, 10],\n            [1, 40, -10],\n            [1, 45, -20],\n            [1, 50, -20],\n            [0, 20, -50],\n            [1, 20, -35],\n            [1, 10, -40],\n            [1, 0, -30],\n            [1, -10, -40],\n            [1, -20, -35],\n            [1, -20, -50],\n            [0, -50, -20],\n            [1, -40, -20],\n            [1, -35, -10],\n            [1, -45, 0],\n            [1, -30, 10],\n            [1, -35, 20],\n            [1, -50, 20]\n        ]);\n    } else {\n        krakel(ctx, [\n            [0, -20, -50],\n            [1, -20, -20],\n            [1, -50, -20],\n            [0, 20, -50],\n            [1, 20, -20],\n            [1, 50, -20],\n            [0, -50, 20],\n            [1, 50, 20]\n        ]);\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config';\nimport { krakel } from './utils';\n\nexport default ({ ctx, row, col, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        krakel(ctx, [\n            [0, -20, 50],\n            [1, -20, 45],\n            [1, -10, 40],\n            [1, 0, 45],\n            [1, 10, 35],\n            [1, 20, 40],\n            [1, 20, 50],\n            [0, 50, 20],\n            [1, 40, 20],\n            [1, 45, 10],\n            [1, 40, -10],\n            [1, 45, -20],\n            [1, 50, -20],\n            [0, 20, -50],\n            [1, 20, -35],\n            [1, 10, -40],\n            [1, 0, -30],\n            [1, -10, -40],\n            [1, -20, -35],\n            [1, -20, -50],\n            [0, -50, -20],\n            [1, -40, -20],\n            [1, -35, -10],\n            [1, -45, 0],\n            [1, -30, 10],\n            [1, -35, 20],\n            [1, -50, 20]\n        ]);\n    } else {\n        krakel(ctx, [\n            [0, -20, -50],\n            [1, -20, -20],\n            [1, -50, -20],\n            [0, 20, -50],\n            [1, 20, -20],\n            [1, 50, -20],\n            [0, -50, 20],\n            [1, -20, 20],\n            [1, -20, 50],\n            [0, 50, 20],\n            [1, 20, 20],\n            [1, 20, 50]\n        ]);\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config';\nimport { krakel } from './utils';\n\nexport default ({ ctx, row, col, broken }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    krakel(ctx, [\n        [0, 30, -48],\n        [1, 48, -30],\n        [1, 48, 30],\n        [1, 30, 48],\n        [1, -30, 48],\n        [1, -48, 30],\n        [1, -48, -30],\n        [1, -30, -48],\n        [1, 30, -48]\n    ]);\n    ctx.stroke();\n    if (broken) {\n        ctx.lineWidth = 2;\n        krakel(ctx, [\n            [0, 10, -48],\n            [1, 0, -40],\n            [0, 24, -48],\n            [1, 20, -30],\n            [0, 48, -27],\n            [1, 20, -20],\n            [0, -10, -30],\n            [1, 10, -30],\n            [1, 30, -10],\n            [1, 20, 0],\n            [1, 10, 0],\n            [0, 48, 7],\n            [1, 30, 10],\n            [0, 20, 0],\n            [1, 30, 10],\n            [1, 10, 20],\n            [0, 30, 48],\n            [1, 30, 30],\n            [1, 10, 30],\n            [0, 20, 20],\n            [1, 20, 30],\n            [0, -10, 48],\n            [1, -10, 20],\n            [1, 0, 10],\n            [0, -20, 0],\n            [1, -20, 20],\n            [1, -10, 30],\n            [0, -30, 48],\n            [1, -20, 40],\n            [1, -20, 30],\n            [0, -30, 30],\n            [1, -20, 40],\n            [0, -48, 20],\n            [1, -30, 20],\n            [0, -40, 20],\n            [1, -40, 10],\n            [0, -48, 0],\n            [1, -30, 0],\n            [1, -20, -10],\n            [0, -40, 0],\n            [1, -30, 10],\n            [0, -48, -17],\n            [1, -40, -30],\n            [1, -30, -20],\n            [0, -30, -48],\n            [1, -10, -20],\n            [1, -10, -10],\n            [0, -20, -30],\n            [1, -20, -20],\n            [1, -30, -10]\n        ]);\n        ctx.stroke();\n    }\n    ctx.restore();\n};\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config';\nimport { degreesToRadians as deg2rad } from '../../utils';\nimport { krakel } from './utils';\n\nexport default ({ ctx, row, col, deg, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.rotate(deg2rad(deg));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        krakel(ctx, [[0, -20, 50], [1, -20, 40], [1, -10, 45], [1, 0, 35], [1, 10, 45], [1, 20, 40], [1, 20, 50]]);\n    } else {\n        krakel(ctx, [[0, -20, 50], [1, -20, 0], [1, 20, 0], [1, 20, 50]]);\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","/* global kontra */\nimport { flatIndex } from './utils';\n\n/**\n * A tile engine for rendering tilesets. Works well with the tile engine program Tiled.\n * @memberof kontra\n *\n * @param {object} properties - Properties of the tile engine.\n * @param {number} [properties.tileWidth=32] - Width of a tile.\n * @param {number} [properties.tileHeight=32] - Height of a tile.\n * @param {number} properties.width - Width of the map (in tiles).\n * @param {number} properties.height - Height of the map (in tiles).\n * @param {number} [properties.x=0] - X position to draw.\n * @param {number} [properties.y=0] - Y position to draw.\n * @param {number} [properties.sx=0] - X position to clip the tileset.\n * @param {number} [properties.sy=0] - Y position to clip the tileset.\n * @param {Context} [properties.context=kontra.context] - Provide a context for the tile engine to draw on.\n */\nexport default (properties = {}) => {\n    // size of the map (in tiles)\n    // @if DEBUG\n    if (!properties.width || !properties.height) {\n        throw Error('You must provide width and height properties');\n    }\n    // @endif\n    const width = properties.width;\n    const height = properties.height;\n\n    // size of the tiles. Most common tile size on opengameart.org seems to be 32x32,\n    // followed by 16x16\n    // Tiled names the property tilewidth and tileheight\n    const tileWidth = properties.tileWidth || 32;\n    const tileHeight = properties.tileHeight || 32;\n\n    const mapWidth = width * tileWidth;\n    const mapHeight = height * tileHeight;\n\n    const context = properties.context || kontra.context;\n    const canvasWidth = context.canvas.width;\n    const canvasHeight = context.canvas.height;\n\n    // create an off-screen canvas for pre-rendering the map\n    // @see http://jsperf.com/render-vs-prerender\n    const offscreenCanvas = document.createElement('canvas');\n    const offscreenContext = offscreenCanvas.getContext('2d');\n\n    // when clipping an image, sx and sy must within the image region, otherwise\n    // Firefox and Safari won't draw it.\n    // @see http://stackoverflow.com/questions/19338032/canvas-indexsizeerror-index-or-size-is-negative-or-greater-than-the-allowed-a\n    const sxMax = Math.max(0, mapWidth - canvasWidth);\n    const syMax = Math.max(0, mapHeight - canvasHeight);\n\n    let _sx, _sy;\n\n    // draw order of layers (by name)\n    const layerOrder = [];\n\n    const tileEngine = {\n        width,\n        height,\n\n        tileWidth,\n        tileHeight,\n\n        mapWidth,\n        mapHeight,\n\n        context,\n\n        x: properties.x || 0,\n        y: properties.y || 0,\n\n        tilesets: [],\n        layers: {},\n\n        /**\n         * Add an tileset for the tile engine to use.\n         * @memberof kontra.tileEngine\n         */\n        addTilesets: function addTilesets(tilesets) {\n            [].concat(tilesets).forEach(tileset => {\n                const tilesetImage = tileset.image;\n                let image, firstGrid, lastTileset, tiles;\n\n                // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n                if (`${tilesetImage}` === tilesetImage) {\n                    let i = Infinity;\n\n                    while (i >= 0) {\n                        i = tilesetImage.lastIndexOf('/', i);\n                        const path = i < 0 ? tilesetImage : tilesetImage.substr(i);\n\n                        if (kontra.assets.images[path]) {\n                            image = kontra.assets.images[path];\n                            break;\n                        }\n\n                        i--;\n                    }\n                } else {\n                    image = tilesetImage;\n                }\n\n                firstGrid = tileset.firstGrid;\n\n                // if the width or height of the provided image is smaller than the tile size,\n                // default calculation to 1\n                const numTiles = ((image.width / tileWidth) | 0 || 1) * ((image.height / tileHeight) | 0 || 1);\n\n                if (!firstGrid) {\n                    // only calculate the first grid if the tile map has a tileset already\n                    if (tileEngine.tilesets.length > 0) {\n                        lastTileset = tileEngine.tilesets[tileEngine.tilesets.length - 1];\n                        tiles =\n                            ((lastTileset.image.width / tileWidth) | 0) * ((lastTileset.image.height / tileHeight) | 0);\n\n                        firstGrid = lastTileset.firstGrid + tiles;\n                    }\n                    // otherwise this is the first tile added to the tile map\n                    else {\n                        firstGrid = 1;\n                    }\n                }\n\n                tileEngine.tilesets.push({\n                    firstGrid,\n                    lastGrid: firstGrid + numTiles - 1,\n                    image\n                });\n\n                // sort the tile map so we can perform a binary search when drawing\n                tileEngine.tilesets.sort((a, b) => a.firstGrid - b.firstGrid);\n            });\n        },\n\n        /**\n         * Add a layer to the tile engine.\n         * @memberof kontra.tileEngine\n         */\n        addLayers: function addLayers(layers) {\n            [].concat(layers).forEach(layer => {\n                // eslint-disable-next-line no-param-reassign\n                layer.render = layer.render === undefined ? true : layer.render;\n\n                let data, row, c, value;\n\n                // flatten a 2D array into a single array\n                if (Array.isArray(layer.data[0])) {\n                    data = [];\n\n                    // eslint-disable-next-line no-cond-assign\n                    for (let r = 0; (row = layer.data[r]); r++) {\n                        for (c = 0; c < width; c++) {\n                            data.push(row[c] || 0);\n                        }\n                    }\n                } else {\n                    data = layer.data;\n                }\n\n                tileEngine.layers[layer.name] = {\n                    data,\n                    zIndex: layer.zIndex || 0,\n                    render: layer.render\n                };\n\n                // merge properties of layer onto layer object\n                for (const prop in layer.properties) {\n                    if (layer.properties.hasOwnProperty(prop)) {\n                        value = layer.properties[prop];\n\n                        try {\n                            value = JSON.parse(value);\n                        } catch (e) {\n                            /* intentionally empty */\n                        }\n\n                        tileEngine.layers[layer.name][prop] = value;\n                    }\n                }\n\n                // only add the layer to the layer order if it should be drawn\n                if (tileEngine.layers[layer.name].render) {\n                    layerOrder.push(layer.name);\n\n                    layerOrder.sort((a, b) => tileEngine.layers[a].zIndex - tileEngine.layers[b].zIndex);\n                }\n            });\n\n            preRenderImage();\n        },\n\n        changeTile(layerId, { row, col }, tile) {\n            const dataIndex = flatIndex(row, col, width);\n            const layer = tileEngine.layers[layerId];\n            layer.data[dataIndex] = tile;\n            renderTile(layer, dataIndex, true);\n        },\n\n        /**\n         * Simple bounding box collision test for layer tiles.\n         * @memberof kontra.tileEngine\n         *\n         * @param {string} name - Name of the layer.\n         * @param {object} object - Object to check collision against.\n         * @param {number} object.x - X coordinate of the object.\n         * @param {number} object.y - Y coordinate of the object.\n         * @param {number} object.width - Width of the object.\n         * @param {number} object.height - Height of the object.\n         *\n         * @returns {boolean} True if the object collides with a tile, false otherwise.\n         */\n        layerCollidesWith: function layerCollidesWith(name, object) {\n            // calculate all tiles that the object can collide with\n            const row = tileEngine.getRow(object.y);\n            const col = tileEngine.getCol(object.x);\n\n            const endRow = tileEngine.getRow(object.y + object.height);\n            const endCol = tileEngine.getCol(object.x + object.width);\n\n            // check all tiles\n            let index;\n            for (let r = row; r <= endRow; r++) {\n                for (let c = col; c <= endCol; c++) {\n                    index = getIndex({ row: r, col: c });\n\n                    if (tileEngine.layers[name].data[index]) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        },\n\n        /**\n         * Get the tile from the specified layer at x, y or row, col.\n         * @memberof kontra.tileEngine\n         *\n         * @param {string} name - Name of the layer.\n         * @param {object} position - Position of the tile in either x, y or row, col.\n         * @param {number} position.x - X coordinate of the tile.\n         * @param {number} position.y - Y coordinate of the tile.\n         * @param {number} position.row - Row of the tile.\n         * @param {number} position.col - Col of the tile.\n         *\n         * @returns {number}\n         */\n        tileAtLayer(name, position) {\n            const index = getIndex(position);\n\n            if (index >= 0) {\n                return tileEngine.layers[name].data[index];\n            }\n            return undefined;\n        },\n\n        /**\n         * Render the pre-rendered canvas.\n         * @memberof kontra.tileEngine\n         */\n        render() {\n            tileEngine.context.drawImage(\n                offscreenCanvas,\n                tileEngine.sx,\n                tileEngine.sy,\n                canvasWidth,\n                canvasHeight,\n                tileEngine.x,\n                tileEngine.y,\n                canvasWidth,\n                canvasHeight\n            );\n        },\n\n        /**\n         * Render a specific layer.\n         * @memberof kontra.tileEngine\n         *\n         * @param {string} name - Name of the layer to render.\n         */\n        renderLayer: function renderLayer(name) {\n            const layer = tileEngine.layers[name];\n\n            // calculate the starting tile\n            let row = tileEngine.getRow();\n            const col = tileEngine.getCol();\n            let index = getIndex({ row, col });\n\n            // calculate where to start drawing the tile relative to the drawing canvas\n            const startX = col * tileWidth - tileEngine.sx;\n            const startY = row * tileHeight - tileEngine.sy;\n\n            // calculate how many tiles the drawing canvas can hold\n            const viewWidth = Math.min(Math.ceil(canvasWidth / tileWidth) + 1, width);\n            const viewHeight = Math.min(Math.ceil(canvasHeight / tileHeight) + 1, height);\n            const numTiles = viewWidth * viewHeight;\n\n            let count = 0;\n            let x, y, tile, tileset, image, tileOffset, w, sx, sy;\n\n            // draw just enough of the layer to fit inside the drawing canvas\n            while (count < numTiles) {\n                tile = layer.data[index];\n\n                if (tile) {\n                    tileset = getTileset(tile);\n                    image = tileset.image;\n\n                    x = startX + (count % viewWidth) * tileWidth;\n                    y = startY + ((count / viewWidth) | 0) * tileHeight;\n\n                    tileOffset = tile - tileset.firstGrid;\n                    w = image.width / tileWidth;\n\n                    sx = (tileOffset % w) * tileWidth;\n                    sy = ((tileOffset / w) | 0) * tileHeight;\n\n                    tileEngine.context.drawImage(image, sx, sy, tileWidth, tileHeight, x, y, tileWidth, tileHeight);\n                }\n\n                if (++count % viewWidth === 0) {\n                    index = col + ++row * width;\n                } else {\n                    index++;\n                }\n            }\n        },\n\n        /**\n         * Get the row from the y coordinate.\n         * @memberof kontra.tileEngine\n         *\n         * @param {number} y - Y coordinate.\n         *\n         * @return {number}\n         */\n        getRow(y) {\n            // eslint-disable-next-line no-param-reassign\n            y = y || 0;\n\n            return ((tileEngine.sy + y) / tileHeight) | 0;\n        },\n\n        /**\n         * Get the col from the x coordinate.\n         * @memberof kontra.tileEngine\n         *\n         * @param {number} x - X coordinate.\n         *\n         * @return {number}\n         */\n        getCol(x) {\n            // eslint-disable-next-line no-param-reassign\n            x = x || 0;\n\n            return ((tileEngine.sx + x) / tileWidth) | 0;\n        },\n\n        get sx() {\n            return _sx;\n        },\n\n        get sy() {\n            return _sy;\n        },\n\n        // ensure sx and sy are within the image region\n        set sx(value) {\n            _sx = Math.min(Math.max(0, value), sxMax);\n        },\n\n        set sy(value) {\n            _sy = Math.min(Math.max(0, value), syMax);\n        },\n\n        // expose properties for testing\n        // @if DEBUG\n        _layerOrder: layerOrder\n        // @endif\n    };\n\n    // set here so we use setter function\n    tileEngine.sx = properties.sx || 0;\n    tileEngine.sy = properties.sy || 0;\n\n    // make the off-screen canvas the full size of the map\n    offscreenCanvas.width = mapWidth;\n    offscreenCanvas.height = mapHeight;\n\n    // merge properties of the tile engine onto the tile engine itself\n    for (const prop in properties.properties) {\n        if (properties.properties.hasOwnProperty(prop)) {\n            let value = properties.properties[prop];\n\n            try {\n                value = JSON.parse(value);\n            } catch (e) {\n                /* intentionally empty */\n            }\n\n            // passed in properties override properties.properties\n            tileEngine[prop] = tileEngine[prop] || value;\n        }\n    }\n\n    if (properties.tilesets) {\n        tileEngine.addTilesets(properties.tilesets);\n    }\n\n    if (properties.layers) {\n        tileEngine.addLayers(properties.layers);\n    }\n\n    /**\n     * Get the index of the x, y or row, col.\n     * @memberof kontra.tileEngine\n     * @private\n     *\n     * @param {number} position.x - X coordinate of the tile.\n     * @param {number} position.y - Y coordinate of the tile.\n     * @param {number} position.row - Row of the tile.\n     * @param {number} position.col - Col of the tile.\n     *\n     * @return {number} Returns the tile index or -1 if the x, y or row,\n     *         col is outside the dimensions of the tile engine.\n     */\n    function getIndex(position) {\n        let row, col;\n\n        if (typeof position.x !== 'undefined' && typeof position.y !== 'undefined') {\n            row = tileEngine.getRow(position.y);\n            col = tileEngine.getCol(position.x);\n        } else {\n            row = position.row;\n            col = position.col;\n        }\n\n        // don't calculate out of bound numbers\n        if (row < 0 || col < 0 || row >= height || col >= width) {\n            return -1;\n        }\n\n        return col + row * width;\n    }\n\n    /**\n     * Modified binary search that will return the tileset associated with the tile\n     * @memberof kontra.tileEngine\n     * @private\n     *\n     * @param {number} tile - Tile grid.\n     *\n     * @return {object}\n     */\n    function getTileset(tile) {\n        let min = 0;\n        let max = tileEngine.tilesets.length - 1;\n        let index, currTile;\n\n        while (min <= max) {\n            index = ((min + max) / 2) | 0;\n            currTile = tileEngine.tilesets[index];\n\n            if (tile >= currTile.firstGrid && tile <= currTile.lastGrid) {\n                return currTile;\n            } else if (currTile.lastGrid < tile) {\n                min = index + 1;\n            } else {\n                max = index - 1;\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Pre-render the tiles to make drawing fast.\n     * @memberof kontra.tileEngine\n     * @private\n     */\n    function preRenderImage() {\n        // draw each layer in order\n        // eslint-disable-next-line no-cond-assign\n        for (let layerIndex = 0, layer; (layer = tileEngine.layers[layerOrder[layerIndex]]); layerIndex++) {\n            for (let dataIndex = 0, len = layer.data.length; dataIndex < len; dataIndex++) {\n                renderTile(layer, dataIndex);\n            }\n        }\n    }\n\n    function renderTile(layer, dataIndex, clear = false) {\n        const tile = layer.data[dataIndex];\n\n        // skip empty tiles (0)\n        if (!tile) {\n            return;\n        }\n\n        const tileset = getTileset(tile);\n        const image = tileset.image;\n\n        const x = (dataIndex % width) * tileWidth;\n        const y = ((dataIndex / width) | 0) * tileHeight;\n\n        const tileOffset = tile - tileset.firstGrid;\n        const w = image.width / tileWidth;\n\n        const sx = (tileOffset % w) * tileWidth;\n        const sy = ((tileOffset / w) | 0) * tileHeight;\n\n        if (clear) {\n            offscreenContext.clearRect(x, y, tileWidth, tileHeight);\n        }\n        offscreenContext.drawImage(image, sx, sy, tileWidth, tileHeight, x, y, tileWidth, tileHeight);\n    }\n\n    return tileEngine;\n};\n","export default (row, col, width) => (row - 1) * width + col - 1;\n","/* global kontra */\n\nimport {\n    tileHeight,\n    tileWidth,\n    mapHeight as height,\n    mapWidth as width,\n    mapPaddingX,\n    mapPaddingY,\n    playerStartCol,\n    playerStartRow\n} from '../config';\nimport { calculateCameraCoordinates } from '../utils';\nimport mapData from './mapData';\nimport { addPadding } from './utils';\nimport { createTilesheet } from './tilesheet';\nimport { createTileEngine } from '../tileEngine';\n\nexport default async () => {\n    const { sx, sy } = calculateCameraCoordinates({ col: playerStartCol, row: playerStartRow });\n    const map = createTileEngine({\n        // tile size\n        tileWidth,\n        tileHeight,\n\n        // map size in tiles\n        width: width + mapPaddingX * 2,\n        height: height + mapPaddingY * 2,\n\n        sx,\n        sy\n    });\n\n    const paddedMap = addPadding(mapData, width, height, mapPaddingX, mapPaddingY);\n    const image = await createTilesheet();\n    map.addTilesets({ image });\n    // map.addTilesets({ image: kontra.assets.images.tilesheet });\n    map.addLayers([\n        {\n            name: 'main',\n            data: paddedMap\n        },\n        {\n            name: 'debug',\n            data: new Array(paddedMap.length).fill(0)\n        }\n        // {\n        //     name: 'grid',\n        //     data: new Array(paddedMap.length).fill(8)\n        // }\n    ]);\n    return map;\n};\n","import { tileHeight, tileWidth } from '../config';\n\nexport default ({ col, row }) => ({\n    sx: (col - 1) * tileWidth + tileWidth / 2,\n    sy: (row - 1) * tileHeight + tileHeight / 2\n});\n","export default (arr, w, h, x, y) => {\n    const retVal = [];\n    let idx = 0;\n    for (let row = 0; row < h + y * 2; row++) {\n        for (let col = 0; col < w + x * 2; col++) {\n            if (row < y || row >= y + h || col < x || col >= x + w) {\n                retVal.push(0);\n                continue;\n            }\n            retVal.push(arr[idx++]);\n        }\n    }\n    return retVal;\n};\n","import { tileHeight, tileWidth } from '../../config';\nimport { drawCurve, drawStraight, drawTSection, drawCrossing, drawServer, drawTerminus } from '.';\n\nexport default () => {\n    const canvas = document.createElement('canvas');\n    canvas.width = 8 * tileWidth;\n    canvas.height = 8 * tileHeight;\n    const ctx = canvas.getContext('2d');\n    drawCurve({ ctx, row: 1, col: 1, deg: 0 });\n    drawCurve({ ctx, row: 1, col: 2, deg: 90 });\n    drawCurve({ ctx, row: 2, col: 1, deg: 270 });\n    drawCurve({ ctx, row: 2, col: 2, deg: 180 });\n    drawStraight({ ctx, row: 1, col: 3, deg: 0 });\n    drawStraight({ ctx, row: 2, col: 3, deg: 90 });\n    drawTSection({ ctx, row: 1, col: 4, deg: 0 });\n    drawTSection({ ctx, row: 1, col: 5, deg: 90 });\n    drawTSection({ ctx, row: 1, col: 6, deg: 180 });\n    drawTSection({ ctx, row: 2, col: 5, deg: 270 });\n    drawCrossing({ ctx, row: 2, col: 4 });\n    drawTerminus({ ctx, row: 3, col: 1, deg: 0 });\n    drawTerminus({ ctx, row: 3, col: 2, deg: 90 });\n    drawTerminus({ ctx, row: 3, col: 3, deg: 180 });\n    drawTerminus({ ctx, row: 3, col: 4, deg: 270 });\n    drawServer({ ctx, row: 2, col: 6 });\n    drawCurve({ ctx, row: 4, col: 1, deg: 0, broken: true });\n    drawCurve({ ctx, row: 4, col: 2, deg: 90, broken: true });\n    drawCurve({ ctx, row: 5, col: 1, deg: 270, broken: true });\n    drawCurve({ ctx, row: 5, col: 2, deg: 180, broken: true });\n    drawStraight({ ctx, row: 4, col: 3, deg: 0, broken: true });\n    drawStraight({ ctx, row: 5, col: 3, deg: 90, broken: true });\n    drawTSection({ ctx, row: 4, col: 4, deg: 0, broken: true });\n    drawTSection({ ctx, row: 4, col: 5, deg: 90, broken: true });\n    drawTSection({ ctx, row: 4, col: 6, deg: 180, broken: true });\n    drawTSection({ ctx, row: 5, col: 5, deg: 270, broken: true });\n    drawCrossing({ ctx, row: 5, col: 4, broken: true });\n    drawTerminus({ ctx, row: 6, col: 1, deg: 0, broken: true });\n    drawTerminus({ ctx, row: 6, col: 2, deg: 90, broken: true });\n    drawTerminus({ ctx, row: 6, col: 3, deg: 180, broken: true });\n    drawTerminus({ ctx, row: 6, col: 4, deg: 270, broken: true });\n    drawServer({ ctx, row: 5, col: 6, broken: true });\n    if (process.env.NODE_ENV === 'development') {\n        require('./drawDebugGrid').default({ ctx, row: 1, col: 8 });\n    }\n    const image = new Image();\n    image.src = canvas.toDataURL('image/png');\n    // document.getElementById('wrapper').appendChild(image);\n    return new Promise(resolve => setTimeout(() => resolve(image), 100));\n};\n","class MessageBox {\n    constructor() {\n        this.timeoutHandler = null;\n        this.div = document.createElement('div');\n        this.div.style.cssText = `\nbackground-color: rgba(0,0,0,0);\nfont-size: 3em;\nfont-weight: bold;\nalign-items: center;\njustify-content: center;\ndisplay: flex;\ncolor: rgba(255,255,255,0);\nposition: absolute;\ntop: 0;\nleft:0;\nwidth: 100vw;\nheight: 100vh;\ntext-align: center;\npointer-events: none;\ntransition: background-color 3s ease-out, color 3s ease-out;\ntext-transform: uppercase;\nfont-family: monospace;\n    `;\n        const wrapper = document.getElementById('wrapper');\n        wrapper.appendChild(this.div);\n    }\n\n    show(message) {\n        clearTimeout(this.timeoutHandler);\n        this.div.style.transition = '3s';\n        this.div.innerHTML = `<div>${message}</div>`;\n        this.div.style.backgroundColor = 'rgba(0,0,0,0.5)';\n        this.div.style.color = 'rgba(255,255,255,1)';\n    }\n\n    flash(message) {\n        clearTimeout(this.timeoutHandler);\n        this.div.style.transition = '0.5s';\n        this.div.innerHTML = `<div>${message}</div>`;\n        this.div.style.color = 'rgba(255,255,255,1)';\n        this.timeoutHandler = setTimeout(() => (this.div.style.color = 'rgba(255,255,255,0)'), 500);\n    }\n}\nexport default new MessageBox();\n","/* global kontra */\n\nimport { drawPlayer, updatePlayer } from '.';\nimport { canvasHeight, canvasWidth, playerStartDirection, collisionRadius } from '../config';\nimport { pubsub, GAME_OVER, DROP_SHIP } from '../pubsub';\nimport { collides } from '../utils';\nimport { messageBox } from '../messageBox';\n\nexport default map => {\n    const player = kontra.sprite({\n        x: canvasWidth / 2,\n        y: canvasHeight / 2,\n        collisionRadius,\n        map,\n        infected: false,\n        gameOver: false,\n        direction: playerStartDirection,\n        nextDirection: null,\n        dropBomb: false,\n        scale: 1,\n        dropping: false,\n        bombCoolingDown: false,\n\n        update() {\n            ({\n                nextDirection: this.nextDirection,\n                direction: this.direction,\n                dropBomb: this.dropBomb,\n                scale: this.scale,\n                bombCoolingDown: this.bombCoolingDown\n            } = updatePlayer(this, pubsub, messageBox));\n        },\n\n        render() {\n            drawPlayer(this);\n        },\n\n        infect(virus) {\n            if (collides(virus, this)) {\n                // eslint-disable-next-line no-param-reassign\n                this.infected = true;\n                if (!this.gameOver) {\n                    messageBox.show('player infected<br>game over');\n                    pubsub.publish(GAME_OVER);\n                }\n            }\n        }\n    });\n\n    pubsub.subscribe(GAME_OVER, () => (player.gameOver = true));\n    pubsub.subscribe(DROP_SHIP, () => (player.dropping = true));\n\n    return player;\n};\n","import { lightGreen, darkGreen, lightRed, darkRed } from '../config';\nimport { calculateRotation } from '../utils';\n\nexport default sprite => {\n    const { context: ctx, x, y, direction, infected, scale } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.scale(scale, scale);\n    ctx.rotate(calculateRotation(direction));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = infected ? lightRed : lightGreen;\n    ctx.fillStyle = infected ? darkRed : darkGreen;\n    ctx.beginPath();\n    ctx.moveTo(-15, 25);\n    ctx.lineTo(0, -25);\n    ctx.lineTo(15, 25);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n};\n","import { degreesToRadians } from '.';\nimport { N, E, S, W } from '../directions';\n\nexport default direction => {\n    switch (direction) {\n        case N:\n            return degreesToRadians(0);\n        case E:\n            return degreesToRadians(90);\n        case S:\n            return degreesToRadians(180);\n        case W:\n            return degreesToRadians(270);\n        default:\n            return null;\n    }\n};\n","import { directionIsAllowed, switchDirection } from '../directions';\nimport { pubsub, DROP_BOMB, DROP_SHIP, GAME_OVER } from '../pubsub';\nimport { getKey, isInTheMiddle } from './utils';\nimport { calculateRowAndCol } from '../utils';\nimport { messageBox } from '../messageBox';\nimport { bombCooldown } from '../config';\n\nexport default sprite => {\n    let { nextDirection, direction, dropBomb, scale, bombCoolingDown } = sprite;\n    const { dropping } = sprite;\n    if (dropping) {\n        if (scale > 0) {\n            scale -= 0.01;\n        } else {\n            messageBox.show('You fell into the abyss<br>Game over');\n            pubsub.publish(GAME_OVER);\n        }\n        return { direction, nextDirection, dropBomb, scale, bombCoolingDown };\n    }\n    const { map, x, y, gameOver } = sprite;\n    if (!gameOver) {\n        ({ nextDirection, dropBomb } = getKey(sprite));\n        if (bombCoolingDown) {\n            dropBomb = false;\n        }\n    }\n    if (!isInTheMiddle({ x: map.sx, y: map.sy })) {\n        return { direction, nextDirection, dropBomb, scale, bombCoolingDown };\n    }\n    if (nextDirection && directionIsAllowed(map, { x, y }, nextDirection)) {\n        direction = nextDirection;\n        nextDirection = null;\n    } else {\n        try {\n            direction = switchDirection(map, { x, y }, direction);\n        } catch ({ message }) {\n            if (message === 'dropped') {\n                pubsub.publish(DROP_SHIP);\n            }\n        }\n    }\n    if (dropBomb) {\n        pubsub.publish(DROP_BOMB, calculateRowAndCol(map));\n        dropBomb = false;\n        bombCoolingDown = true;\n        setTimeout(() => {\n            // eslint-disable-next-line no-param-reassign\n            sprite.bombCoolingDown = false;\n        }, bombCooldown);\n    }\n    return { direction, nextDirection, dropBomb, scale, bombCoolingDown };\n};\n","/* global kontra */\n\nimport { N, E, S, W } from '../../directions';\n\nexport default sprite => {\n    let { nextDirection, dropBomb } = sprite;\n    if (kontra.keys.pressed('right')) {\n        nextDirection = E;\n    }\n    if (kontra.keys.pressed('left')) {\n        nextDirection = W;\n    }\n    if (kontra.keys.pressed('up')) {\n        nextDirection = N;\n    }\n    if (kontra.keys.pressed('down')) {\n        nextDirection = S;\n    }\n    if (kontra.keys.pressed('space')) {\n        dropBomb = true;\n    }\n    return { nextDirection, dropBomb };\n};\n","import { tileHeight, tileWidth } from '../../config';\n\nexport default ({ x, y }) => (x - tileWidth / 2) % tileWidth === 0 && (y - tileHeight / 2) % tileHeight === 0;\n","export default ({ sx, sy, tileWidth, tileHeight }) => ({\n    col: Math.floor(sx / tileWidth) + 1,\n    row: Math.floor(sy / tileHeight) + 1\n});\n","import { INFECTED } from '../constants';\n\nexport default users => users.every(user => user.state === INFECTED);\n","/* global kontra */\n\nimport { drawUser, INFECTED } from '.';\nimport { tileWidth, tileHeight, collisionRadius } from '../config';\nimport { pubsub, INFECTED as INFECTED_EVENT } from '../pubsub'\nimport { transformMapCoordinates } from '../utils';\nimport { ONLINE } from '.';\n\nexport default ({ map, row, col }) => {\n    const { x, y } = transformMapCoordinates(map, { row, col });\n    return kontra.sprite({\n        x,\n        y,\n        collisionRadius,\n        infected: false,\n        map,\n        mapX: (col - 1) * tileWidth,\n        mapY: (row - 1) * tileHeight,\n        status: ONLINE,\n        update() {\n            ({ x: this.x, y: this.y } = transformMapCoordinates(this.map, { x: this.mapX, y: this.mapY }));\n        },\n        render() {\n            drawUser(this);\n        },\n        infect() {\n            this.status = INFECTED;\n            pubsub.publish(INFECTED_EVENT)\n        }\n    });\n};\n","export const ONLINE = 0;\nexport const OFFLINE = 1;\nexport const INFECTED = 2;\n","/* global kontra */\nimport { lightBlue, darkBlue, lightGreen, darkGreen, lightRed, darkRed } from '../config';\nimport { ONLINE, OFFLINE, INFECTED } from './constants';\nimport { degreesToRadians as deg2rad } from '../utils';\n\nconst spriteMapping = {\n    [ONLINE]: { fg: lightBlue, bg: darkBlue },\n    [OFFLINE]: { fg: lightGreen, bg: darkGreen },\n    [INFECTED]: { fg: lightRed, bg: darkRed }\n};\n\nexport default sprite => {\n    const { context: ctx, x, y, status } = sprite;\n    const { fg, bg } = spriteMapping[status];\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = fg;\n    ctx.fillStyle = bg;\n    ctx.beginPath();\n    ctx.moveTo(-40, 40);\n    ctx.lineTo(-40, 20);\n    ctx.arc(-20, 20, 20, deg2rad(180), deg2rad(270));\n    ctx.moveTo(-20, 0);\n    ctx.lineTo(20, 0);\n    ctx.arc(20, 20, 20, deg2rad(270), deg2rad(0));\n    ctx.lineTo(40, 40);\n    ctx.lineTo(-40, 40);\n    ctx.moveTo(-23, 20);\n    ctx.lineTo(-23, 40);\n    ctx.moveTo(23, 20);\n    ctx.lineTo(23, 40);\n    ctx.fill();\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(0, -15, 25, deg2rad(0), deg2rad(360));\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n};\n","/* global kontra */\n\nimport { virusStartDirection, virusStartCol, virusStartRow, tileWidth, tileHeight, collisionRadius } from '../config';\nimport { transformMapCoordinates } from '../utils';\nimport { drawVirus, updateVirus, Blips } from '.';\n\nexport default map => {\n    const { x, y } = transformMapCoordinates(map, { row: virusStartRow, col: virusStartCol });\n    const blips = new Blips();\n    const virus = kontra.sprite({\n        x,\n        y,\n        collisionRadius,\n        map,\n        mapX: (virusStartCol - 1) * tileWidth,\n        mapY: (virusStartRow - 1) * tileHeight,\n        direction: virusStartDirection,\n        blips,\n        update() {\n            ({ x: this.x, y: this.y, mapX: this.mapX, mapY: this.mapY, direction: this.direction } = updateVirus(this));\n            this.blips.update();\n        },\n        render() {\n            drawVirus(this);\n            this.blips.render();\n        }\n    });\n    blips.start(virus);\n\n    return virus;\n};\n","import {\n    switchDirection,\n    isIntersection,\n    directionSwitchMap,\n    getOppositeDirection,\n    directionIsAllowed\n} from '../directions';\nimport { transformMapCoordinates, getRandomInt } from '../utils';\nimport { isInTheMiddle, moveVirus, getBestDirection } from './utils';\nimport { mapWidth, mapHeight, tileWidth, tileHeight } from '../config';\n\nconst visits = Array(mapHeight)\n    .fill()\n    .map(() => Array(mapWidth).fill(0));\n\nexport default sprite => {\n    let { direction, x, y } = sprite;\n    const { map } = sprite;\n    const { mapX, mapY } = moveVirus(sprite);\n    if (isInTheMiddle({ mapX, mapY })) {\n        const tile = map.tileAtLayer('main', { x, y });\n        const col = mapX / tileWidth + 1;\n        const row = mapY / tileHeight + 1;\n        visits[row - 1][col - 1] = visits[row - 1][col - 1] + 1;\n        if (isIntersection(tile)) {\n            const { allowed } = directionSwitchMap[tile];\n            const viable = allowed.filter(\n                dir => dir !== getOppositeDirection(direction) && directionIsAllowed(map, { x, y }, dir)\n            );\n            const bestDirections = getBestDirection({ viable, visits, row, col });\n            direction = bestDirections[getRandomInt(0, bestDirections.length - 1)];\n        } else {\n            direction = switchDirection(map, { x, y }, direction);\n        }\n    }\n    ({ x, y } = transformMapCoordinates(map, { x: mapX, y: mapY }));\n    return {\n        direction,\n        mapY,\n        mapX,\n        x,\n        y\n    };\n};\n","import { N, E, S, W } from '../../directions';\nimport { virusSpeed } from '../../config';\n\nexport default ({ mapX, mapY, direction }) => {\n    switch (direction) {\n        case N:\n            return { mapX, mapY: mapY - virusSpeed };\n        case E:\n            return { mapX: mapX + virusSpeed, mapY };\n        case S:\n            return { mapX, mapY: mapY + virusSpeed };\n        case W:\n            return { mapX: mapX - virusSpeed, mapY };\n        default:\n            return { mapX, mapY };\n    }\n};\n","import { tileHeight, tileWidth } from '../../config';\n\nexport default ({ mapX, mapY }) => mapX % tileWidth === 0 && mapY % tileHeight === 0;\n","import { N, E, S, W } from '../../directions';\n\nexport default ({ viable, visits, row, col }) => {\n    let minVis = Number.MAX_SAFE_INTEGER;\n    return viable\n        .map(dir => {\n            let vis;\n            switch (dir) {\n                case N:\n                    vis = visits[row - 2][col - 1];\n                    break;\n                case E:\n                    vis = visits[row - 1][col];\n                    break;\n                case S:\n                    vis = visits[row][col - 1];\n                    break;\n                case W:\n                    vis = visits[row - 1][col - 2];\n                    break;\n                default:\n            }\n            minVis = vis < minVis ? vis : minVis;\n            return { dir, vis };\n        })\n        .filter(({ vis }) => vis === minVis)\n        .map(({ dir }) => dir);\n};\n","import { N, E, S, W } from '.';\n\nexport default direction => {\n    switch (direction) {\n        case N:\n            return S;\n        case E:\n            return W;\n        case S:\n            return N;\n        case W:\n            return W;\n        default:\n            return null;\n    }\n};\n","import { lightRed, darkRed } from '../config';\nimport { getRandomInt as ri } from '../utils';\n\nexport default sprite => {\n    const { context: ctx, x, y } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightRed;\n    ctx.fillStyle = darkRed;\n    ctx.beginPath();\n    ctx.moveTo(ri(-5, 5), ri(-5, -25)); // 1\n    ctx.lineTo(ri(5, 50), ri(-5, -50)); // 2\n    ctx.lineTo(ri(5, 25), ri(-5, 5)); // 3\n    ctx.lineTo(ri(5, 50), ri(5, 50)); // 4\n    ctx.lineTo(ri(-5, 5), ri(5, 25)); // 5\n    ctx.lineTo(ri(-5, -50), ri(5, 50)); // 6\n    ctx.lineTo(ri(-5, -25), ri(-5, 5)); // 7\n    ctx.lineTo(ri(-5, -50), ri(-5, -50)); // 8\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.restore();\n};\n","/* global kontra */\n\nimport { tileHeight, virusBlipTtl } from '../config';\nimport { drawBlip } from '.';\n\nexport default ({ x, y }) =>\n    kontra.sprite({\n        x,\n        y,\n        ttl: virusBlipTtl,\n        radius: tileHeight,\n        update() {\n            this.radius += 10;\n            this.ttl--;\n        },\n        render() {\n            drawBlip(this);\n        }\n    });\n","import { lightRed } from '../config';\nimport { degreesToRadians as deg2rad } from '../utils';\n\nexport default sprite => {\n    const { context: ctx, x, y, radius } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = lightRed;\n    ctx.beginPath();\n    ctx.arc(0, 0, radius, deg2rad(0), deg2rad(360));\n    ctx.closePath();\n    ctx.stroke();\n\n    ctx.restore();\n};\n","import { virusBlipInterval } from '../config';\nimport { createBlip } from '.';\n\nexport default class {\n    constructor() {\n        this.blips = [];\n    }\n\n    start(virus) {\n        setInterval(() => {\n            this.blips.push(createBlip({ x: virus.x, y: virus.y }));\n        }, virusBlipInterval);\n    }\n    update() {\n        this.blips.forEach(blip => blip.update());\n        this.blips = this.blips.filter(blip => blip.ttl > 0);\n    }\n    render() {\n        this.blips.forEach(blip => blip.render());\n    }\n}\n","/* global kontra */\n\nimport { collisionRadius, tileHeight, tileWidth } from '../config';\nimport { transformMapCoordinates } from '../utils';\nimport { drawBomb, updateBomb } from '.';\nimport { FUSE_BURNING } from '.';\n\nexport default (map, { row, col }) => {\n    const { x, y } = transformMapCoordinates(map, { row, col });\n    return kontra.sprite({\n        x,\n        y,\n        collisionRadius,\n        fuseLength: 100,\n        status: FUSE_BURNING,\n        shrapnel: [],\n        explosionDuration: 0,\n        map,\n        mapX: (col - 1) * tileWidth,\n        mapY: (row - 1) * tileHeight,\n        row,\n        col,\n        update() {\n            ({\n                status: this.status,\n                fuseLength: this.fuseLength,\n                explosionDuration: this.explosionDuration,\n                x: this.x,\n                y: this.y\n            } = updateBomb(this));\n        },\n        render() {\n            drawBomb(this);\n        }\n    });\n};\n","export const FUSE_BURNING = 0;\nexport const EXPLODING = 1;\nexport const EXPLODED = 2;\n","import { EXPLODING, FUSE_BURNING } from './constants';\nimport { drawBombWithFuse } from '.';\n\nexport default sprite => {\n    const { status, shrapnel } = sprite;\n    switch (status) {\n        case FUSE_BURNING:\n            drawBombWithFuse(sprite);\n            break;\n        case EXPLODING:\n            shrapnel.forEach(s => s.render());\n            break;\n        default:\n    }\n};\n","import { lightRed, lightBlue, darkBlue } from '../config';\nimport { getRandomInt as ri } from '../utils';\nimport { degreesToRadians as deg2rad } from '../utils';\n\nexport default sprite => {\n    const { context: ctx, x, y, fuseLength } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(deg2rad(-45));\n\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.fillStyle = darkBlue;\n\n    /* bomb */\n    ctx.beginPath();\n    ctx.moveTo(23, -10);\n    ctx.lineTo(40, -10);\n    ctx.lineTo(40, 10);\n    ctx.lineTo(23, 10);\n    ctx.arc(0, 0, 25, deg2rad(19), deg2rad(341));\n    ctx.fill();\n    ctx.stroke();\n\n    /* fuse */\n    const fuseRad = 25; // radius of the fuse arc\n    const fuseDeg = (fuseLength / 100) * 90; // length of the fuse arc in degrees\n    ctx.beginPath();\n    ctx.moveTo(40, 0);\n    ctx.arc(40, 25, fuseRad, deg2rad(270), deg2rad(270 + fuseDeg));\n    ctx.stroke();\n\n    /* sparks */\n    const sparkCX = Math.cos(deg2rad(fuseDeg - 90)) * fuseRad + 40; // X-coord of sparks center\n    const sparkCY = Math.sin(deg2rad(fuseDeg - 90)) * fuseRad + 25; // Y-coord of sparks centers\n    const sparkRad = 15; // radius of the sparks circle\n    ctx.fillStyle = lightRed;\n    for (let i = 0; i < 10; i++) {\n        const sparkX = Math.cos(deg2rad(ri(0, 360))) * ri(0, sparkRad) + sparkCX;\n        const sparkY = Math.sin(deg2rad(ri(0, 360))) * ri(0, sparkRad) + sparkCY;\n        ctx.fillRect(sparkX - 1, sparkY - 1, 3, 3);\n    }\n\n    ctx.restore();\n};\n","/* global kontra */\n\nimport { FUSE_BURNING, EXPLODING, EXPLODED } from '.';\nimport { createShrapnel } from '.';\nimport { transformMapCoordinates } from '../utils';\nimport { mapPaddingX, mapPaddingY } from '../config';\nimport { pubsub, BOMB_EXPLODES } from '../pubsub'\n\nexport default sprite => {\n    let { status, fuseLength, explosionDuration, x, y } = sprite;\n    const { shrapnel, map, mapX, mapY, row, col } = sprite;\n\n    ({ x, y } = transformMapCoordinates(map, { x: mapX, y: mapY }));\n    switch (status) {\n        case FUSE_BURNING:\n            fuseLength -= 1;\n            if (fuseLength < 0) {\n                status = EXPLODING;\n                pubsub.publish(BOMB_EXPLODES)\n                for (let i = 0; i < 50; i++) {\n                    shrapnel.push(createShrapnel({ x, y }));\n                }\n                const tile = map.tileAtLayer('main', { row: row + mapPaddingY - 1, col: col + mapPaddingX - 1 });\n                map.changeTile('main', { row: row + mapPaddingY, col: col + mapPaddingX }, tile + 24);\n            }\n            break;\n        case EXPLODING:\n            shrapnel.forEach(s => s.update());\n            explosionDuration++;\n            if (explosionDuration === 200) {\n                status = EXPLODED;\n            }\n            break;\n        default:\n    }\n    return {\n        status,\n        fuseLength,\n        explosionDuration,\n        x,\n        y\n    };\n};\n","/* global kontra */\nimport { getRandomInt as ri } from '../utils';\nimport { degreesToRadians as deg2rad } from '../utils';\nimport { drawShrapnel } from '.';\n\nexport default ({ x, y }) => {\n    const dir = ri(0, 360);\n    const speed = ri(5, 15);\n    return kontra.sprite({\n        x,\n        y,\n        dx: Math.cos(deg2rad(dir)) * speed,\n        dy: Math.sin(deg2rad(dir)) * speed,\n        rotation: ri(0, 360),\n        rotationDir: [ri(-10, -1), ri(1, 10)][ri(0, 1)],\n        update() {\n            this.advance();\n            this.rotation += this.rotationDir;\n        },\n        render() {\n            drawShrapnel(this);\n        }\n    });\n};\n","import { lightBlue, darkBlue } from '../config';\nimport { degreesToRadians as deg2rad } from '../utils';\n\nexport default sprite => {\n    const { context: ctx, x, y, rotation } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(deg2rad(rotation));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.fillStyle = darkBlue;\n    ctx.beginPath();\n    ctx.moveTo(0, -10);\n    ctx.lineTo(10, 5);\n    ctx.lineTo(-10, 5);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n};\n","/*\n * RIFFWAVE.js v0.02 - Audio encoder for HTML5 <audio> elements.\n * Copyright (C) 2011 Pedro Ladaria <pedro.ladaria at Gmail dot com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * version 2 as published by the Free Software Foundation.\n * The full license is available at http://www.gnu.org/licenses/gpl.html\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n *\n * Changelog:\n *\n * 0.01 - First release\n * 0.02 - New faster base64 encoding\n *\n */\n\nvar FastBase64 = {\n\n  chars: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n  encLookup: [],\n\n  Init: function() {\n    for (var i=0; i<4096; i++) {\n      this.encLookup[i] = this.chars[i >> 6] + this.chars[i & 0x3F];\n    }\n  },\n\n  Encode: function(src) {\n    var len = src.length;\n    var dst = '';\n    var i = 0;\n    let n\n    while (len > 2) {\n      n = (src[i] << 16) | (src[i+1]<<8) | src[i+2];\n      dst+= this.encLookup[n >> 12] + this.encLookup[n & 0xFFF];\n      len-= 3;\n      i+= 3;\n    }\n    if (len > 0) {\n      var n1= (src[i] & 0xFC) >> 2;\n      var n2= (src[i] & 0x03) << 4;\n      if (len > 1) n2 |= (src[++i] & 0xF0) >> 4;\n      dst+= this.chars[n1];\n      dst+= this.chars[n2];\n      if (len == 2) {\n        var n3= (src[i++] & 0x0F) << 2;\n        n3 |= (src[i] & 0xC0) >> 6;\n        dst+= this.chars[n3];\n      }\n      if (len == 1) dst+= '=';\n      dst+= '=';\n    }\n    return dst;\n  } // end Encode\n\n}\n\nFastBase64.Init();\n\nvar RIFFWAVE = function(data) {\n\n  this.data = [];        // Byte array containing audio samples\n  this.wav = [];         // Array containing the generated wave file\n  this.dataURI = '';     // http://en.wikipedia.org/wiki/Data_URI_scheme\n\n  this.header = {                         // OFFS SIZE NOTES\n    chunkId      : [0x52,0x49,0x46,0x46], // 0    4    \"RIFF\" = 0x52494646\n    chunkSize    : 0,                     // 4    4    36+SubChunk2Size = 4+(8+SubChunk1Size)+(8+SubChunk2Size)\n    format       : [0x57,0x41,0x56,0x45], // 8    4    \"WAVE\" = 0x57415645\n    subChunk1Id  : [0x66,0x6d,0x74,0x20], // 12   4    \"fmt \" = 0x666d7420\n    subChunk1Size: 16,                    // 16   4    16 for PCM\n    audioFormat  : 1,                     // 20   2    PCM = 1\n    numChannels  : 1,                     // 22   2    Mono = 1, Stereo = 2, etc.\n    sampleRate   : 8000,                  // 24   4    8000, 44100, etc\n    byteRate     : 0,                     // 28   4    SampleRate*NumChannels*BitsPerSample/8\n    blockAlign   : 0,                     // 32   2    NumChannels*BitsPerSample/8\n    bitsPerSample: 8,                     // 34   2    8 bits = 8, 16 bits = 16, etc...\n    subChunk2Id  : [0x64,0x61,0x74,0x61], // 36   4    \"data\" = 0x64617461\n    subChunk2Size: 0                      // 40   4    data size = NumSamples*NumChannels*BitsPerSample/8\n  };\n\n  function u32ToArray(i) { return [i&0xFF, (i>>8)&0xFF, (i>>16)&0xFF, (i>>24)&0xFF]; }\n\n  function u16ToArray(i) { return [i&0xFF, (i>>8)&0xFF]; }\n\n  this.Make = function(data) {\n    if (data instanceof Array) this.data = data;\n    this.header.byteRate = (this.header.sampleRate * this.header.numChannels * this.header.bitsPerSample) >> 3;\n    this.header.blockAlign = (this.header.numChannels * this.header.bitsPerSample) >> 3;\n    this.header.subChunk2Size = this.data.length;\n    this.header.chunkSize = 36 + this.header.subChunk2Size;\n\n    this.wav = this.header.chunkId.concat(\n        u32ToArray(this.header.chunkSize),\n        this.header.format,\n        this.header.subChunk1Id,\n        u32ToArray(this.header.subChunk1Size),\n        u16ToArray(this.header.audioFormat),\n        u16ToArray(this.header.numChannels),\n        u32ToArray(this.header.sampleRate),\n        u32ToArray(this.header.byteRate),\n        u16ToArray(this.header.blockAlign),\n        u16ToArray(this.header.bitsPerSample),\n        this.header.subChunk2Id,\n        u32ToArray(this.header.subChunk2Size),\n        this.data\n    );\n    this.dataURI = 'data:audio/wav;base64,'+FastBase64.Encode(this.wav);\n  };\n\n  if (data instanceof Array) this.Make(data);\n\n}; // end RIFFWAVE\n\n\nexport default RIFFWAVE\n","import RIFFWAVE from './riffwave'\n\n\n// Wave shapes\nvar SQUARE = 0;\nvar SAWTOOTH = 1;\nvar SINE = 2;\nvar NOISE = 3;\n\n\n// Playback volume\nvar masterVolume = 1;\n\n\nvar OVERSAMPLING = 8;\n\n\nfunction sqr(x) { return x * x }\nfunction cube(x) { return x * x * x }\nfunction sign(x) { return x < 0 ? -1 : 1 }\nfunction log(x, b) { return Math.log(x) / Math.log(b); }\nvar pow = Math.pow;\n\n\n// Translate from UI-friendly settings to human-friendly ones\n\n// Sound generation parameters are on [0,1] unless noted SIGNED & thus\n// on [-1,1]\nfunction Params() {\n  this.oldParams = true;  // Note what structure this is\n\n  // Wave shape\n  this.wave_type = SQUARE;\n\n  // Envelope\n  this.p_env_attack = 0;   // Attack time\n  this.p_env_sustain = 0.3;  // Sustain time\n  this.p_env_punch = 0;    // Sustain punch\n  this.p_env_decay = 0.4;    // Decay time\n\n  // Tone\n  this.p_base_freq = 0.3;    // Start frequency\n  this.p_freq_limit = 0;   // Min frequency cutoff\n  this.p_freq_ramp = 0;    // Slide (SIGNED)\n  this.p_freq_dramp = 0;   // Delta slide (SIGNED)\n  // Vibrato\n  this.p_vib_strength = 0; // Vibrato depth\n  this.p_vib_speed = 0;    // Vibrato speed\n\n  // Tonal change\n  this.p_arp_mod = 0;      // Change amount (SIGNED)\n  this.p_arp_speed = 0;    // Change speed\n\n  // Square wave duty (proportion of time signal is high vs. low)\n  this.p_duty = 0;         // Square duty\n  this.p_duty_ramp = 0;    // Duty sweep (SIGNED)\n\n  // Repeat\n  this.p_repeat_speed = 0; // Repeat speed\n\n  // Flanger\n  this.p_pha_offset = 0;   // Flanger offset (SIGNED)\n  this.p_pha_ramp = 0;     // Flanger sweep (SIGNED)\n\n  // Low-pass filter\n  this.p_lpf_freq = 1;     // Low-pass filter cutoff\n  this.p_lpf_ramp = 0;     // Low-pass filter cutoff sweep (SIGNED)\n  this.p_lpf_resonance = 0;// Low-pass filter resonance\n  // High-pass filter\n  this.p_hpf_freq = 0;     // High-pass filter cutoff\n  this.p_hpf_ramp = 0;     // High-pass filter cutoff sweep (SIGNED)\n\n  // Sample parameters\n  this.sound_vol = 0.5;\n  this.sample_rate = 44100;\n  this.sample_size = 8;\n}\n\n\nfunction frnd(range) {\n  return Math.random() * range;\n}\n\nfunction rndr(from, to) {\n  return Math.random() * (to - from) + from;\n}\n\nfunction rnd(max) {\n  return Math.floor(Math.random() * (max + 1));\n}\n\n\n// These functions roll up random sounds appropriate to various\n// typical game events:\n\n\n/*Params.prototype.pickupCoin = function () {\n  this.p_base_freq = 0.4 + frnd(0.5);\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.1);\n  this.p_env_decay = 0.1 + frnd(0.4);\n  this.p_env_punch = 0.3 + frnd(0.3);\n  if (rnd(1)) {\n    this.p_arp_speed = 0.5 + frnd(0.2);\n    this.p_arp_mod = 0.2 + frnd(0.4);\n  }\n  return this;\n}*/\n\n\n\n\n/*Params.prototype.laserShoot = function () {\n  this.wave_type = rnd(2);\n  if(this.wave_type === SINE && rnd(1))\n    this.wave_type = rnd(1);\n  if (rnd(2) === 0) {\n    this.p_base_freq = 0.3 + frnd(0.6);\n    this.p_freq_limit = frnd(0.1);\n    this.p_freq_ramp = -0.35 - frnd(0.3);\n  } else {\n    this.p_base_freq = 0.5 + frnd(0.5);\n    this.p_freq_limit = this.p_base_freq - 0.2 - frnd(0.6);\n    if (this.p_freq_limit < 0.2) this.p_freq_limit = 0.2;\n    this.p_freq_ramp = -0.15 - frnd(0.2);\n  }\n  if (this.wave_type === SAWTOOTH)\n    this.p_duty = 1;\n  if (rnd(1)) {\n    this.p_duty = frnd(0.5);\n    this.p_duty_ramp = frnd(0.2);\n  } else {\n    this.p_duty = 0.4 + frnd(0.5);\n    this.p_duty_ramp = -frnd(0.7);\n  }\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.2);\n  this.p_env_decay = frnd(0.4);\n  if (rnd(1))\n    this.p_env_punch = frnd(0.3);\n  if (rnd(2) === 0) {\n    this.p_pha_offset = frnd(0.2);\n    this.p_pha_ramp = -frnd(0.2);\n  }\n  //if (rnd(1))\n  this.p_hpf_freq = frnd(0.3);\n\n  return this;\n}*/\n\n\n\n\nParams.prototype.explosion = function () {\n  this.wave_type = NOISE;\n  if (rnd(1)) {\n    this.p_base_freq = sqr(0.1 + frnd(0.4));\n    this.p_freq_ramp = -0.1 + frnd(0.4);\n  } else {\n    this.p_base_freq = sqr(0.2 + frnd(0.7));\n    this.p_freq_ramp = -0.2 - frnd(0.2);\n  }\n  if (rnd(4) === 0)\n    this.p_freq_ramp = 0;\n  if (rnd(2) === 0)\n    this.p_repeat_speed = 0.3 + frnd(0.5);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.3);\n  this.p_env_decay = frnd(0.5);\n  if (rnd(1)) {\n    this.p_pha_offset = -0.3 + frnd(0.9);\n    this.p_pha_ramp = -frnd(0.3);\n  }\n  this.p_env_punch = 0.2 + frnd(0.6);\n  if (rnd(1)) {\n    this.p_vib_strength = frnd(0.7);\n    this.p_vib_speed = frnd(0.6);\n  }\n  if (rnd(2) === 0) {\n    this.p_arp_speed = 0.6 + frnd(0.3);\n    this.p_arp_mod = 0.8 - frnd(1.6);\n  }\n\n  return this;\n}\n\n\n\n\n/*Params.prototype.powerUp = function () {\n  if (rnd(1)) {\n    this.wave_type = SAWTOOTH;\n    this.p_duty = 1;\n  } else {\n    this.p_duty = frnd(0.6);\n  }\n  this.p_base_freq = 0.2 + frnd(0.3);\n  if (rnd(1)) {\n    this.p_freq_ramp = 0.1 + frnd(0.4);\n    this.p_repeat_speed = 0.4 + frnd(0.4);\n  } else {\n    this.p_freq_ramp = 0.05 + frnd(0.2);\n    if (rnd(1)) {\n      this.p_vib_strength = frnd(0.7);\n      this.p_vib_speed = frnd(0.6);\n    }\n  }\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.4);\n  this.p_env_decay = 0.1 + frnd(0.4);\n\n  return this;\n}*/\n\n\n\n\nParams.prototype.hitHurt = function () {\n  this.wave_type = rnd(2);\n  if (this.wave_type === SINE)\n    this.wave_type = NOISE;\n  if (this.wave_type === SQUARE)\n    this.p_duty = frnd(0.6);\n  if (this.wave_type === SAWTOOTH)\n    this.p_duty = 1;\n  this.p_base_freq = 0.2 + frnd(0.6);\n  this.p_freq_ramp = -0.3 - frnd(0.4);\n  this.p_env_attack = 0;\n  this.p_env_sustain = frnd(0.1);\n  this.p_env_decay = 0.1 + frnd(0.2);\n  if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n  return this;\n}\n\n\n\n\nParams.prototype.jump = function () {\n  this.wave_type = SQUARE;\n  this.p_duty = frnd(0.6);\n  this.p_base_freq = 0.3 + frnd(0.3);\n  this.p_freq_ramp = 0.1 + frnd(0.2);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.3);\n  this.p_env_decay = 0.1 + frnd(0.2);\n  if (rnd(1))\n    this.p_hpf_freq = frnd(0.3);\n  if (rnd(1))\n    this.p_lpf_freq = 1 - frnd(0.6);\n  return this;\n}\n\n\n\n\n/*Params.prototype.blipSelect = function () {\n  this.wave_type = rnd(1);\n  if (this.wave_type === SQUARE)\n    this.p_duty = frnd(0.6);\n  else\n    this.p_duty = 1;\n  this.p_base_freq = 0.2 + frnd(0.4);\n  this.p_env_attack = 0;\n  this.p_env_sustain = 0.1 + frnd(0.1);\n  this.p_env_decay = frnd(0.2);\n  this.p_hpf_freq = 0.1;\n  return this;\n}*/\n\n\n\n\nParams.prototype.mutate = function () {\n  if (rnd(1)) this.p_base_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_freq_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_freq_dramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_duty += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_duty_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_strength += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_vib_delay += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_attack += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_sustain += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_decay += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_env_punch += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_resonance += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_lpf_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_hpf_freq += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_hpf_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_pha_offset += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_pha_ramp += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_repeat_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_arp_speed += frnd(0.1) - 0.05;\n  if (rnd(1)) this.p_arp_mod += frnd(0.1) - 0.05;\n}\n\n\n\n\n\nfunction SoundEffect(ps) {\n    this.initFromUI(ps);\n}\n\n\nSoundEffect.prototype.initFromUI = function (ps) {\n  //\n  // Convert user-facing parameter values to units usable by the sound\n  // generator\n  //\n\n  this.initForRepeat = function() {\n    this.elapsedSinceRepeat = 0;\n\n    this.period = 100 / (ps.p_base_freq * ps.p_base_freq + 0.001);\n    this.periodMax = 100 / (ps.p_freq_limit * ps.p_freq_limit + 0.001);\n    this.enableFrequencyCutoff = (ps.p_freq_limit > 0);\n    this.periodMult = 1 - Math.pow(ps.p_freq_ramp, 3) * 0.01;\n    this.periodMultSlide = -Math.pow(ps.p_freq_dramp, 3) * 0.000001;\n\n    this.dutyCycle = 0.5 - ps.p_duty * 0.5;\n    this.dutyCycleSlide = -ps.p_duty_ramp * 0.00005;\n\n    if (ps.p_arp_mod >= 0)\n      this.arpeggioMultiplier = 1 - Math.pow(ps.p_arp_mod, 2) * .9;\n    else\n      this.arpeggioMultiplier = 1 + Math.pow(ps.p_arp_mod, 2) * 10;\n    this.arpeggioTime = Math.floor(Math.pow(1 - ps.p_arp_speed, 2) * 20000 + 32);\n    if (ps.p_arp_speed === 1)\n      this.arpeggioTime = 0;\n  }\n\n  this.initForRepeat();  // First time through, this is a bit of a misnomer\n\n  // Waveform shape\n  this.waveShape = parseInt(ps.wave_type);\n\n  // Filter\n  this.fltw = Math.pow(ps.p_lpf_freq, 3) * 0.1;\n  this.enableLowPassFilter = (ps.p_lpf_freq != 1);\n  this.fltw_d = 1 + ps.p_lpf_ramp * 0.0001;\n  this.fltdmp = 5 / (1 + Math.pow(ps.p_lpf_resonance, 2) * 20) *\n      (0.01 + this.fltw);\n  if (this.fltdmp > 0.8) this.fltdmp=0.8;\n  this.flthp = Math.pow(ps.p_hpf_freq, 2) * 0.1;\n  this.flthp_d = 1 + ps.p_hpf_ramp * 0.0003;\n\n  // Vibrato\n  this.vibratoSpeed = Math.pow(ps.p_vib_speed, 2) * 0.01;\n  this.vibratoAmplitude = ps.p_vib_strength * 0.5;\n\n  // Envelope\n  this.envelopeLength = [\n    Math.floor(ps.p_env_attack * ps.p_env_attack * 100000),\n    Math.floor(ps.p_env_sustain * ps.p_env_sustain * 100000),\n    Math.floor(ps.p_env_decay * ps.p_env_decay * 100000)\n  ];\n  this.envelopePunch = ps.p_env_punch;\n\n  // Flanger\n  this.flangerOffset = Math.pow(ps.p_pha_offset, 2) * 1020;\n  if (ps.p_pha_offset < 0) this.flangerOffset = -this.flangerOffset;\n  this.flangerOffsetSlide = Math.pow(ps.p_pha_ramp, 2) * 1;\n  if (ps.p_pha_ramp < 0) this.flangerOffsetSlide = -this.flangerOffsetSlide;\n\n  // Repeat\n  this.repeatTime = Math.floor(Math.pow(1 - ps.p_repeat_speed, 2) * 20000\n      + 32);\n  if (ps.p_repeat_speed === 0)\n    this.repeatTime = 0;\n\n  this.gain = Math.exp(ps.sound_vol) - 1;\n\n  this.sampleRate = ps.sample_rate;\n  this.bitsPerChannel = ps.sample_size;\n}\n\n\n\n\nSoundEffect.prototype.generate = function () {\n  var fltp = 0;\n  var fltdp = 0;\n  var fltphp = 0;\n\n  var noise_buffer = Array(32);\n  for (var i = 0; i < 32; ++i)\n    noise_buffer[i] = Math.random() * 2 - 1;\n\n  var envelopeStage = 0;\n  var envelopeElapsed = 0;\n\n  var vibratoPhase = 0;\n\n  var phase = 0;\n  var ipp = 0;\n  var flanger_buffer = Array(1024);\n  for (var i = 0; i < 1024; ++i)\n    flanger_buffer[i] = 0;\n\n  var num_clipped = 0;\n\n  var buffer = [];\n\n  var sample_sum = 0;\n  var num_summed = 0;\n  var summands = Math.floor(44100 / this.sampleRate);\n\n  for(var t = 0; ; ++t) {\n\n    // Repeats\n    if (this.repeatTime != 0 && ++this.elapsedSinceRepeat >= this.repeatTime)\n      this.initForRepeat();\n\n    // Arpeggio (single)\n    if(this.arpeggioTime != 0 && t >= this.arpeggioTime) {\n      this.arpeggioTime = 0;\n      this.period *= this.arpeggioMultiplier;\n    }\n\n    // Frequency slide, and frequency slide slide!\n    this.periodMult += this.periodMultSlide;\n    this.period *= this.periodMult;\n    if(this.period > this.periodMax) {\n      this.period = this.periodMax;\n      if (this.enableFrequencyCutoff)\n        break;\n    }\n\n    // Vibrato\n    var rfperiod = this.period;\n    if (this.vibratoAmplitude > 0) {\n      vibratoPhase += this.vibratoSpeed;\n      rfperiod = this.period * (1 + Math.sin(vibratoPhase) * this.vibratoAmplitude);\n    }\n    var iperiod = Math.floor(rfperiod);\n    if (iperiod < OVERSAMPLING) iperiod = OVERSAMPLING;\n\n    // Square wave duty cycle\n    this.dutyCycle += this.dutyCycleSlide;\n    if (this.dutyCycle < 0) this.dutyCycle = 0;\n    if (this.dutyCycle > 0.5) this.dutyCycle = 0.5;\n\n    // Volume envelope\n    if (++envelopeElapsed > this.envelopeLength[envelopeStage]) {\n      envelopeElapsed = 0;\n      if (++envelopeStage > 2)\n        break;\n    }\n    var env_vol;\n    var envf = envelopeElapsed / this.envelopeLength[envelopeStage];\n    if (envelopeStage === 0) {         // Attack\n      env_vol = envf;\n    } else if (envelopeStage === 1) {  // Sustain\n      env_vol = 1 + (1 - envf) * 2 * this.envelopePunch;\n    } else {                           // Decay\n      env_vol = 1 - envf;\n    }\n\n    // Flanger step\n    this.flangerOffset += this.flangerOffsetSlide;\n    var iphase = Math.abs(Math.floor(this.flangerOffset));\n    if (iphase > 1023) iphase = 1023;\n\n    if (this.flthp_d != 0) {\n      this.flthp *= this.flthp_d;\n      if (this.flthp < 0.00001)\n        this.flthp = 0.00001;\n      if (this.flthp > 0.1)\n        this.flthp = 0.1;\n    }\n\n    // 8x oversampling\n    var sample = 0;\n    for (var si = 0; si < OVERSAMPLING; ++si) {\n      var sub_sample = 0;\n      phase++;\n      if (phase >= iperiod) {\n        phase %= iperiod;\n        if (this.waveShape === NOISE)\n          for(var i = 0; i < 32; ++i)\n            noise_buffer[i] = Math.random() * 2 - 1;\n      }\n\n      // Base waveform\n      var fp = phase / iperiod;\n      if (this.waveShape === SQUARE) {\n        if (fp < this.dutyCycle)\n          sub_sample=0.5;\n        else\n          sub_sample=-0.5;\n      } else if (this.waveShape === SAWTOOTH) {\n        if (fp < this.dutyCycle)\n          sub_sample = -1 + 2 * fp/this.dutyCycle;\n        else\n          sub_sample = 1 - 2 * (fp-this.dutyCycle)/(1-this.dutyCycle);\n      } else if (this.waveShape === SINE) {\n        sub_sample = Math.sin(fp * 2 * Math.PI);\n      } else if (this.waveShape === NOISE) {\n        sub_sample = noise_buffer[Math.floor(phase * 32 / iperiod)];\n      } else {\n        throw \"ERROR: Bad wave type: \" + this.waveShape;\n      }\n\n      // Low-pass filter\n      var pp = fltp;\n      this.fltw *= this.fltw_d;\n      if (this.fltw < 0) this.fltw = 0;\n      if (this.fltw > 0.1) this.fltw = 0.1;\n      if (this.enableLowPassFilter) {\n        fltdp += (sub_sample - fltp) * this.fltw;\n        fltdp -= fltdp * this.fltdmp;\n      } else {\n        fltp = sub_sample;\n        fltdp = 0;\n      }\n      fltp += fltdp;\n\n      // High-pass filter\n      fltphp += fltp - pp;\n      fltphp -= fltphp * this.flthp;\n      sub_sample = fltphp;\n\n      // Flanger\n      flanger_buffer[ipp & 1023] = sub_sample;\n      sub_sample += flanger_buffer[(ipp - iphase + 1024) & 1023];\n      ipp = (ipp + 1) & 1023;\n\n      // final accumulation and envelope application\n      sample += sub_sample * env_vol;\n    }\n\n    // Accumulate samples appropriately for sample rate\n    sample_sum += sample;\n    if (++num_summed >= summands) {\n      num_summed = 0;\n      sample = sample_sum / summands;\n      sample_sum = 0;\n    } else {\n      continue;\n    }\n\n    sample = sample / OVERSAMPLING * masterVolume;\n    sample *= this.gain;\n\n    if (this.bitsPerChannel === 8) {\n      // Rescale [-1, 1) to [0, 256)\n      sample = Math.floor((sample + 1) * 128);\n      if (sample > 255) {\n        sample = 255;\n        ++num_clipped;\n      } else if (sample < 0) {\n        sample = 0;\n        ++num_clipped;\n      }\n      buffer.push(sample);\n    } else {\n      // Rescale [-1, 1) to [-32768, 32768)\n      sample = Math.floor(sample * (1<<15));\n      if (sample >= (1<<15)) {\n        sample = (1 << 15)-1;\n        ++num_clipped;\n      } else if (sample < -(1<<15)) {\n        sample = -(1 << 15);\n        ++num_clipped;\n      }\n      buffer.push(sample & 0xFF);\n      buffer.push((sample >> 8) & 0xFF);\n    }\n  }\n\n  var wave = new RIFFWAVE();\n  wave.header.sampleRate = this.sampleRate;\n  wave.header.bitsPerSample = this.bitsPerChannel;\n  wave.Make(buffer);\n  wave.clipping = num_clipped;\n  return wave;\n}\n\n\n\n\n\n\n\nexport default {\n  Params,\n  SoundEffect\n}\n","import { pubsub, DROP_BOMB, BOMB_EXPLODES, INFECTED, GAME_OVER } from '../pubsub';\nimport sfxr from '../../vendor/sfxr';\nconst { SoundEffect, Params } = sfxr\n\nconst sounds = {};\n\ngenerate('jump');\ngenerate('explosion');\ngenerate('mutate');\ngenerate('hitHurt');\n\nfunction generate(fx) {\n  const PARAMS = new Params();\n  PARAMS[fx]();\n  var audio = new Audio();\n  const SOUND = new SoundEffect(PARAMS).generate();\n  audio.src = SOUND.dataURI;\n  sounds[fx] = audio;\n}\n\nexport function initAudio() {\n    console.log('init audio');\n    pubsub.subscribe(DROP_BOMB, () => sounds.jump.play());\n    pubsub.subscribe(BOMB_EXPLODES, () => sounds.explosion.play());\n    pubsub.subscribe(INFECTED, () => sounds.mutate.play());\n    pubsub.subscribe(GAME_OVER, () => sounds.hitHurt.play());\n}\n\n\n","/* global kontra */\n\nimport { createCanvas } from './canvas';\nimport { createLoop } from './loop';\nimport { createMap } from './map';\nimport { createPlayer } from './player';\nimport { Users } from './user';\nimport { createVirus } from './virus';\nimport { Bombs } from './bomb';\nimport { initAudio } from './audio';\n\nif (process.env.NODE_ENV === 'development') {\n    require('./devbox/createDevbox').default();\n}\n\n(async () => {\n    createCanvas();\n    kontra.init();\n    const map = await createMap();\n    const player = createPlayer(map);\n    const virus = createVirus(map);\n    const bombs = new Bombs(map);\n    const users = new Users(map);\n    const loop = createLoop({ map, player, virus, users, bombs });\n    initAudio();\n    loop.start();\n})();\n","import { canvasHeight, canvasWidth, lightBlue } from '../config';\n\nexport default () => {\n    const canvas = document.createElement('canvas');\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvas.style.cssText = `\n        border: 4px solid ${lightBlue};\n    `;\n    const wrapper = document.getElementById('wrapper');\n    wrapper.appendChild(canvas);\n};\n","import { pubsub, DROP_BOMB, BOMB_EXPLODES } from '../pubsub';\nimport { EXPLODED } from './constants';\nimport { createBomb } from '.';\n\nexport default class {\n    constructor(map) {\n        this.map = map;\n        this.bombs = [];\n        pubsub.subscribe(DROP_BOMB, mapCoords => this.dropBomb(mapCoords));\n    }\n    dropBomb(mapCoords) {\n        if (\n            this.bombs.length > 0 &&\n            this.bombs.find(({ col, row }) => col === mapCoords.col && row === mapCoords.row)\n        ) {\n            // don't drop a bomb where there already is one waiting to explode\n            return;\n        }\n        this.bombs.push(createBomb(this.map, mapCoords));\n    }\n    update() {\n        this.bombs = this.bombs.filter(bomb => {\n            bomb.update();\n            return bomb.status !== EXPLODED;\n        });\n    }\n    render() {\n        this.bombs.forEach(bomb => bomb.render());\n    }\n}\n","import { createUser, INFECTED } from '.';\nimport { mapHeight, mapWidth, mapPaddingX, mapPaddingY } from '../config';\nimport { multiCollides } from '../utils';\nimport { allInfected } from './utils';\nimport { pubsub, GAME_OVER } from '../pubsub';\nimport { messageBox } from '../messageBox';\n\nexport default class {\n    constructor(map) {\n        this.map = map;\n        this.users = [];\n        this.gameOver = false;\n        for (let row = 1; row <= mapHeight + mapPaddingY * 2; row++) {\n            for (let col = 1; col <= mapWidth + mapPaddingX * 2; col++) {\n                const tile = map.tileAtLayer('main', { row, col });\n                if (tile >= 17 && tile <= 20) {\n                    this.users.push(createUser({ map, row: row - mapPaddingY + 1, col: col - mapPaddingX + 1 }));\n                }\n            }\n        }\n        pubsub.subscribe(GAME_OVER, () => (this.gameOver = true));\n    }\n    update() {\n        this.users.forEach(user => user.update());\n    }\n    render() {\n        this.users.forEach(user => user.render());\n    }\n    infect(viruses) {\n        const { users, gameOver } = this;\n        const userVirusCollisions = multiCollides(users, viruses).filter(([user]) => user.status !== INFECTED);\n        if (userVirusCollisions.length === 0) {\n            return;\n        }\n        userVirusCollisions.forEach(([user]) => user.infect());\n        if (gameOver) {\n            return;\n        }\n        if (allInfected(users)) {\n            messageBox.show('all users infected<br>game over');\n            pubsub.publish(GAME_OVER);\n            return;\n        }\n        messageBox.flash('user infected!');\n    }\n}\n","import { collides } from '.';\n\nexport default (arr1, arr2) => {\n    const collisions = [];\n    for (let i1 = 0; i1 < arr1.length; i1++) {\n        const sprite1 = arr1[i1];\n        for (let i2 = 0; i2 < arr2.length; i2++) {\n            const sprite2 = arr2[i2];\n            if (collides(sprite1, sprite2)) {\n                collisions.push([sprite1, sprite2]);\n            }\n        }\n    }\n    return collisions;\n};\n"],"sourceRoot":""}
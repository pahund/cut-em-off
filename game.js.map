{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/bomb/Bombs.js","webpack:///./src/bomb/constants.js","webpack:///./src/bomb/createBomb.js","webpack:///./src/bomb/createShrapnel.js","webpack:///./src/bomb/drawBomb.js","webpack:///./src/bomb/drawBombWithFuse.js","webpack:///./src/bomb/drawShrapnel.js","webpack:///./src/bomb/index.js","webpack:///./src/bomb/updateBomb.js","webpack:///./src/canvas/createCanvas.js","webpack:///./src/canvas/index.js","webpack:///./src/config.js","webpack:///./src/devbox/createDevbox.js","webpack:///./src/directions/constants.js","webpack:///./src/directions/directionIsAllowed.js","webpack:///./src/directions/directionSwitchMap.js","webpack:///./src/directions/getNextTile.js","webpack:///./src/directions/getOppositeDirection.js","webpack:///./src/directions/index.js","webpack:///./src/directions/isIntersection.js","webpack:///./src/directions/isValidTile.js","webpack:///./src/directions/switchDirection.js","webpack:///./src/index.js","webpack:///./src/loop/createLoop.js","webpack:///./src/loop/index.js","webpack:///./src/loop/utils/index.js","webpack:///./src/loop/utils/moveCamera.js","webpack:///./src/map/createMap.js","webpack:///./src/map/index.js","webpack:///./src/map/mapData.js","webpack:///./src/map/tilesheet/createTilesheet.js","webpack:///./src/map/tilesheet/drawCrossing.js","webpack:///./src/map/tilesheet/drawCurve.js","webpack:///./src/map/tilesheet/drawDebugGrid.js","webpack:///./src/map/tilesheet/drawServer.js","webpack:///./src/map/tilesheet/drawStraight.js","webpack:///./src/map/tilesheet/drawTSection.js","webpack:///./src/map/tilesheet/drawTerminus.js","webpack:///./src/map/tilesheet/index.js","webpack:///./src/map/tilesheet/utils/index.js","webpack:///./src/map/tilesheet/utils/krakel.js","webpack:///./src/map/utils/addPadding.js","webpack:///./src/map/utils/index.js","webpack:///./src/messageBox/index.js","webpack:///./src/messageBox/messageBox.js","webpack:///./src/player/createPlayer.js","webpack:///./src/player/drawPlayer.js","webpack:///./src/player/index.js","webpack:///./src/player/updatePlayer.js","webpack:///./src/player/utils/getKey.js","webpack:///./src/player/utils/index.js","webpack:///./src/player/utils/isInTheMiddle.js","webpack:///./src/pubsub/constants.js","webpack:///./src/pubsub/index.js","webpack:///./src/pubsub/pubsub.js","webpack:///./src/tileEngine/createTileEngine.js","webpack:///./src/tileEngine/index.js","webpack:///./src/tileEngine/utils/flatIndex.js","webpack:///./src/tileEngine/utils/index.js","webpack:///./src/user/Users.js","webpack:///./src/user/constants.js","webpack:///./src/user/createUser.js","webpack:///./src/user/drawUser.js","webpack:///./src/user/index.js","webpack:///./src/user/utils/allInfected.js","webpack:///./src/user/utils/index.js","webpack:///./src/utils/calculateCameraCoordinates.js","webpack:///./src/utils/calculateRotation.js","webpack:///./src/utils/calculateRowAndCol.js","webpack:///./src/utils/collides.js","webpack:///./src/utils/degreesToRadians.js","webpack:///./src/utils/getRandomInt.js","webpack:///./src/utils/index.js","webpack:///./src/utils/multiCollides.js","webpack:///./src/utils/transformMapCoordinates.js","webpack:///./src/virus/createVirus.js","webpack:///./src/virus/drawDebugVirus.js","webpack:///./src/virus/drawVirus.js","webpack:///./src/virus/index.js","webpack:///./src/virus/updateVirus.js","webpack:///./src/virus/utils/getBestDirections.js","webpack:///./src/virus/utils/index.js","webpack:///./src/virus/utils/isInTheMiddle.js","webpack:///./src/virus/utils/moveVirus.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;AClF4B;AACT;AACE;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;;;;;;;;;;;;;;;;ACFA;AAAA;;AAEiD;AACf;AACH;AACR;;AAEvB,sEAAsB,WAAW;AACjC,WAAW,OAAO,gFAAiC,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACnCA;AAAA;AAC6B;AACS;AACf;;AAEvB,iEAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;ACvBkC;AACP;;AAE3B;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACdwC;AACX;AACS;;AAEtC;AACA,WAAW,iCAAiC;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB,4CAA4C;AAC5C;AACA;AACA;AACA;;AAEA;AACA,2HAAmE;AACnE,2HAAmE;AACnE,wBAAwB;AACxB;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;AC5C8B;AACQ;;AAEtC;AACA,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBgC;AACF;AACQ;AACN;AACE;AACE;AACT;AAC3B;;;;;;;;;;;;;;;;ACPA;AAAA;;AAE4C;AACnB;AACS;AACC;;AAEnC;AACA,SAAS,8CAA8C;AACvD,WAAW,sCAAsC;;AAEjD,MAAM,OAAO,gFAAiC,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC,4FAAkD,OAAO;AACzD;AACA,sDAAsD,yIAAyD;AAC/G,wCAAwC,iIAAiD;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxC+C;;AAE/C;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACXkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAnB;;AAEf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACHuD;;AAEvD,sEAAsB,OAAO;AAC7B,0CAA0C,OAAO;AACjD;AACA;AACA;AACA,iFAAuC,OAAO;AAC9C;AACA;;;;;;;;;;;;;;;ACTqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpHqB;AACW;;AAEhC,sEAAsB,OAAO;AAC7B;AACA;AACA;AACA,KAAK;;;;;;;;;;;;;;;ACPgB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACwC;AACH;AACG;AACJ;AACM;AACT;AACA;;;;;;;;;;;;;;;ACPJ;;AAE7B;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACTA;;;;;;;;;;;;;;;;ACA8D;AACvC;;AAEvB,sEAAsB,OAAO;AAC7B,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA,2EAAiC,OAAO;AACxC;AACA;AACA,gLAAoG,OAAO;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvBA;AAAA;;AAEuB;AACF;AACD;AACG;AACP;AACM;AACN;;AAEhB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA6B,mCAAmC;AAChE;AACA,CAAC;;;;;;;;;;;;;;;;ACxBD;AAAA;;AAEqB;AACQ;AACD;;AAE5B,iEAAiB,mCAAmC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;;AAElC;AACA,6CAA6C,IAAI,YAAY,OAAO,OAAO,OAAO,QAAQ,IAAI,QAAQ,IAAI;AAC1G;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC5CgC;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;ACAV;AACD;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvBA;AAAA;;AAWC;AACoC;AACrC;AACqB;AACK;AACC;;AAE3B;AACA,WAAW,SAAS,8EAA+B,2HAA2C;AAC9F;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,qBAAqB,QAAQ;AAC7B,wBAAwB,wCAAwC;AAChE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpD+B;;;;;;;;;;;;;ACA/B;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtBgC;AACwD;;AAExF;AACA;AACA;AACA;AACA;AACA,yDAAe,8BAA8B;AAC7C,yDAAe,+BAA+B;AAC9C,yDAAe,gCAAgC;AAC/C,yDAAe,gCAAgC;AAC/C,4DAAkB,8BAA8B;AAChD,4DAAkB,+BAA+B;AACjD,4DAAkB,8BAA8B;AAChD,4DAAkB,+BAA+B;AACjD,4DAAkB,gCAAgC;AAClD,4DAAkB,gCAAgC;AAClD,4DAAkB,sBAAsB;AACxC,4DAAkB,8BAA8B;AAChD,4DAAkB,+BAA+B;AACjD,4DAAkB,gCAAgC;AAClD,4DAAkB,gCAAgC;AAClD,0DAAgB,sBAAsB;AACtC,yDAAe,4CAA4C;AAC3D,yDAAe,6CAA6C;AAC5D,yDAAe,8CAA8C;AAC7D,yDAAe,8CAA8C;AAC7D,4DAAkB,4CAA4C;AAC9D,4DAAkB,6CAA6C;AAC/D,4DAAkB,4CAA4C;AAC9D,4DAAkB,6CAA6C;AAC/D,4DAAkB,8CAA8C;AAChE,4DAAkB,8CAA8C;AAChE,4DAAkB,oCAAoC;AACtD,4DAAkB,4CAA4C;AAC9D,4DAAkB,6CAA6C;AAC/D,4DAAkB,8CAA8C;AAChE,4DAAkB,8CAA8C;AAChE,0DAAgB,oCAAoC;AACpD;AACA,oGAA4C,sBAAsB;AAClE;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/CA;AAAA;AAC2C;AAC1B;;AAEjB,iEAAiB,gCAAgC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1DA;AAAA;AACsC;AACK;;AAE3C;AACA;AACA;;AAEA,iEAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxCA;AAAA;AACgC;;AAEhC,iEAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChBA;AAAA;AAC2C;AAC1B;;AAEjB,iEAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/EA;AAAA;AAC2C;AACL;AACrB;;AAEjB,iEAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClCA;AAAA;AAC2C;AACL;AACrB;;AAEjB,iEAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjDA;AAAA;AAC2C;AACL;AACrB;;AAEjB,iEAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBqC;AACN;AACG;AACA;AACA;AACF;AACE;;;;;;;;;;;;;;;;;ACNN;;;;;;;;;;;;;ACA5B;AAAA,yDAAyD;AACzD;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACbgC;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;ACAhC;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3CA;AAAA;;AAEmC;AACwC;AACpC;AACpB;AACE;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACrDmD;AACvB;;+DAE5B;AACA,WAAW,iDAAiD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACpBkC;AACF;AACE;;;;;;;;;;;;;;;;;;;;ACFY;AACI;AAClB;AACH;AACR;AACE;;+DAEvB;AACA,SAAS,6DAA6D;AACtE,WAAW,WAAW;AACtB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA,WAAW,sBAAsB;AACjC;AACA,UAAU,0BAA0B;AACpC;AACA;AACA;AACA;AACA,uEAAwB,uBAAuB;AAC/C,gBAAgB;AAChB;AACA,sGAAkD,OAAO;AACzD;AACA;AACA,KAAK;AACL;AACA,kGAA8C,OAAO;AACrD,SAAS,SAAS,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY;AACZ;;;;;;;;;;;;;;ACnDA;AAAA;;AAEqB;;AAErB;AACA,SAAS,0BAA0B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;;;;;;;;;;;;;;;;;;ACtBmC;AACP;;;;;;;;;;;;;;;ACDI;;AAEhC,iEAAiB,OAAO;;;;;;;;;;;;;;;;;ACFxB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACF4B;AAC5B;;;;;;;;;;;;;;ACDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;;AAEA;;;;;;;;;;;;;;ACbA;AAAA;AACoB;;AAEpB;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,+EAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,aAAa;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,uBAAuB;AAC1D,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA,SAAS;;AAET,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA6B,aAAa;AAC1C,iCAAiC,aAAa;AAC9C,sCAAsC,iBAAiB;;AAEvD;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qDAAqD;AAC5F,4DAA4D,iBAAiB;AAC7E;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;ACrgBsC;;;;;;;;;;;;;;ACAtC;;;;;;;;;;;;;;;;;ACA+B;;;;;;;;;;;;;;;;;;;;ACAA;AACyB;AAChC;AACF;AACM;AACP;;AAErB;AACA;AACA;AACA;AACA;AACA,yBAAyB,oHAAoC;AAC7D,6BAA6B,mHAAmC;AAChE,sDAAsD,WAAW;AACjE;AACA,0FAAgD,8IAA8D;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;;;;;;;;;;;;;;;;ACFA;AAAA;;AAE6B;AACoB;AACf;AACjB;;+DAEjB,EAAiB,gBAAgB;AACjC,WAAW,OAAO,gFAAiC,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB,qFAAsC,6BAA6B;AACxG,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC5BA;AAAA;AACwE;AACpC;AACE;;AAEtC;AACA,0DAAe,8GAA8B;AAC7C,2DAAgB,gHAAgC;AAChD,4DAAiB;AACjB;;AAEA;AACA,WAAW,6BAA6B;AACxC,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvC2B;AACK;AACF;AAC9B;;;;;;;;;;;;;;;ACHmB;;AAEnB;;;;;;;;;;;;;;;;;ACFiC;;;;;;;;;;;;;;;ACAD;;AAEhC,iEAAiB,WAAW;AAC5B;AACA;AACA,CAAC;;;;;;;;;;;;;;;;ACL0B;AACN;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChBA,iEAAiB,gCAAgC;AACjD;AACA;AACA,CAAC;;;;;;;;;;;;;;ACHD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACJA;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJgD;AACT;AACD;AACJ;AACW;AACV;AACL;AACU;;;;;;;;;;;;;;;ACPrB;;AAEnB;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACdoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,sEAAsB,iBAAiB;AACvC,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;AACA,YAAY;AACZ;;;;;;;;;;;;;;;;ACpBA;AAAA;;AAEoG;AAClE;AACD;;AAEjC;AACA,WAAW,OAAO,gFAAiC,yHAAyC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oFAAoF;AAClG,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACvB4B;;AAE5B;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;AC7B4B;AACC;;AAE7B;AACA,WAAW,qBAAqB;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA,yJAAuC;AACvC,yJAAuC;AACvC,uJAAqC;AACrC,uJAAqC;AACrC,uJAAqC;AACrC,yJAAuC;AACvC,yJAAuC;AACvC,2JAAyC;AACzC;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBiC;AACA;AACF;AACK;;;;;;;;;;;;;;;;;;ACGnC;AAC+C;AACK;AACA;;AAErD;AACA;AACA;;AAEA;AACA,SAAS,kBAAkB;AAC3B,WAAW,MAAM;AACjB,WAAW,aAAa;AACxB,sEAAuB,aAAa;AACpC,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA,mMAA2F,OAAO;AAClG;AACA,oGAAqD,2BAA2B;AAChF;AACA,SAAS;AACT,kGAA8C,OAAO;AACrD;AACA;AACA,MAAM,OAAO,gFAAiC,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3CqB;;AAErB,iEAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT,kBAAkB,MAAM;AACxB,eAAe,MAAM;AACrB;;;;;;;;;;;;;;;;;;;;;;;AC3BmC;AACJ;AACO;;;;;;;;;;;;;;;ACFN;;AAEhC,iEAAiB,aAAa;;;;;;;;;;;;;;;;ACFT;AACA;;AAErB,iEAAiB,wBAAwB;AACzC;AACA;AACA,oBAAoB;AACpB;AACA,oBAAoB;AACpB;AACA,oBAAoB;AACpB;AACA,oBAAoB;AACpB;AACA,oBAAoB;AACpB;AACA","file":"game.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","import { pubsub, DROP_BOMB } from '../pubsub';\nimport { EXPLODED } from './constants';\nimport { createBomb } from '.';\n\nexport default class {\n    constructor(map) {\n        this.map = map;\n        this.bombs = [];\n        pubsub.subscribe(DROP_BOMB, mapCoords => this.dropBomb(mapCoords));\n    }\n    dropBomb(mapCoords) {\n        if (\n            this.bombs.length > 0 &&\n            this.bombs.find(({ col, row }) => col === mapCoords.col && row === mapCoords.row)\n        ) {\n            // don't drop a bomb where there already is one waiting to explode\n            return;\n        }\n        this.bombs.push(createBomb(this.map, mapCoords));\n    }\n    update() {\n        this.bombs = this.bombs.filter(bomb => {\n            bomb.update();\n            return bomb.status !== EXPLODED;\n        });\n    }\n    render() {\n        this.bombs.forEach(bomb => bomb.render());\n    }\n}\n","export const FUSE_BURNING = 0;\nexport const EXPLODING = 1;\nexport const EXPLODED = 2;\n","/* global kontra */\n\nimport { collisionRadius, tileHeight, tileWidth } from '../config';\nimport { transformMapCoordinates } from '../utils';\nimport { drawBomb, updateBomb } from '.';\nimport { FUSE_BURNING } from '.';\n\nexport default (map, { row, col }) => {\n    const { x, y } = transformMapCoordinates(map, { row, col });\n    return kontra.sprite({\n        x,\n        y,\n        collisionRadius,\n        fuseLength: 100,\n        status: FUSE_BURNING,\n        shrapnel: [],\n        explosionDuration: 0,\n        map,\n        mapX: (col - 1) * tileWidth,\n        mapY: (row - 1) * tileHeight,\n        row,\n        col,\n        update() {\n            ({\n                status: this.status,\n                fuseLength: this.fuseLength,\n                explosionDuration: this.explosionDuration,\n                x: this.x,\n                y: this.y\n            } = updateBomb(this));\n        },\n        render() {\n            drawBomb(this);\n        }\n    });\n};\n","/* global kontra */\nimport { getRandomInt as ri } from '../utils';\nimport { degreesToRadians as deg2rad } from '../utils';\nimport { drawShrapnel } from '.';\n\nexport default ({ x, y }) => {\n    const dir = ri(0, 360);\n    const speed = ri(5, 15);\n    return kontra.sprite({\n        x,\n        y,\n        dx: Math.cos(deg2rad(dir)) * speed,\n        dy: Math.sin(deg2rad(dir)) * speed,\n        rotation: ri(0, 360),\n        rotationDir: [ri(-10, -1), ri(1, 10)][ri(0, 1)],\n        update() {\n            this.advance();\n            this.rotation += this.rotationDir;\n        },\n        render() {\n            drawShrapnel(this);\n        }\n    });\n};\n","import { EXPLODING, FUSE_BURNING } from './constants';\nimport { drawBombWithFuse } from '.';\n\nexport default sprite => {\n    const { status, shrapnel } = sprite;\n    switch (status) {\n        case FUSE_BURNING:\n            drawBombWithFuse(sprite);\n            break;\n        case EXPLODING:\n            shrapnel.forEach(s => s.render());\n            break;\n        default:\n    }\n};\n","import { lightRed, lightBlue, darkBlue } from '../config';\nimport { getRandomInt as ri } from '../utils';\nimport { degreesToRadians as deg2rad } from '../utils';\n\nexport default sprite => {\n    const { context: ctx, x, y, fuseLength } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(deg2rad(-45));\n\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.fillStyle = darkBlue;\n\n    /* bomb */\n    ctx.beginPath();\n    ctx.moveTo(23, -10);\n    ctx.lineTo(40, -10);\n    ctx.lineTo(40, 10);\n    ctx.lineTo(23, 10);\n    ctx.arc(0, 0, 25, deg2rad(19), deg2rad(341));\n    ctx.fill();\n    ctx.stroke();\n\n    /* fuse */\n    const fuseRad = 25; // radius of the fuse arc\n    const fuseDeg = (fuseLength / 100) * 90; // length of the fuse arc in degrees\n    ctx.beginPath();\n    ctx.moveTo(40, 0);\n    ctx.arc(40, 25, fuseRad, deg2rad(270), deg2rad(270 + fuseDeg));\n    ctx.stroke();\n\n    /* sparks */\n    const sparkCX = Math.cos(deg2rad(fuseDeg - 90)) * fuseRad + 40; // X-coord of sparks center\n    const sparkCY = Math.sin(deg2rad(fuseDeg - 90)) * fuseRad + 25; // Y-coord of sparks centers\n    const sparkRad = 15; // radius of the sparks circle\n    ctx.fillStyle = lightRed;\n    for (let i = 0; i < 10; i++) {\n        const sparkX = Math.cos(deg2rad(ri(0, 360))) * ri(0, sparkRad) + sparkCX;\n        const sparkY = Math.sin(deg2rad(ri(0, 360))) * ri(0, sparkRad) + sparkCY;\n        ctx.fillRect(sparkX - 1, sparkY - 1, 3, 3);\n    }\n\n    ctx.restore();\n};\n","import { lightBlue, darkBlue } from '../config';\nimport { degreesToRadians as deg2rad } from '../utils';\n\nexport default sprite => {\n    const { context: ctx, x, y, rotation } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(deg2rad(rotation));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.fillStyle = darkBlue;\n    ctx.beginPath();\n    ctx.moveTo(0, -10);\n    ctx.lineTo(10, 5);\n    ctx.lineTo(-10, 5);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n};\n","export { default as createBomb } from './createBomb';\nexport { default as drawBomb } from './drawBomb';\nexport { default as drawBombWithFuse } from './drawBombWithFuse';\nexport { default as updateBomb } from './updateBomb';\nexport { default as drawShrapnel } from './drawShrapnel';\nexport { default as createShrapnel } from './createShrapnel';\nexport { default as Bombs } from './Bombs';\nexport * from './constants';\n","/* global kontra */\n\nimport { FUSE_BURNING, EXPLODING, EXPLODED } from '.';\nimport { createShrapnel } from '.';\nimport { transformMapCoordinates } from '../utils';\nimport { mapPaddingX, mapPaddingY } from '../config';\n\nexport default sprite => {\n    let { status, fuseLength, explosionDuration, x, y } = sprite;\n    const { shrapnel, map, mapX, mapY, row, col } = sprite;\n\n    ({ x, y } = transformMapCoordinates(map, { x: mapX, y: mapY }));\n    switch (status) {\n        case FUSE_BURNING:\n            fuseLength -= 1;\n            if (fuseLength < 0) {\n                status = EXPLODING;\n                for (let i = 0; i < 50; i++) {\n                    shrapnel.push(createShrapnel({ x, y }));\n                }\n                const tile = map.tileAtLayer('main', { row: row + mapPaddingY - 1, col: col + mapPaddingX - 1 });\n                map.changeTile('main', { row: row + mapPaddingY, col: col + mapPaddingX }, tile + 24);\n            }\n            break;\n        case EXPLODING:\n            shrapnel.forEach(s => s.update());\n            explosionDuration++;\n            if (explosionDuration === 200) {\n                status = EXPLODED;\n            }\n            break;\n        default:\n    }\n    return {\n        status,\n        fuseLength,\n        explosionDuration,\n        x,\n        y\n    };\n};\n","import { canvasHeight, canvasWidth, lightBlue } from '../config';\n\nexport default () => {\n    const canvas = document.createElement('canvas');\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvas.style.cssText = `\n        border: 4px solid ${lightBlue};\n    `;\n    const wrapper = document.getElementById('wrapper');\n    wrapper.appendChild(canvas);\n};\n","export { default as createCanvas } from './createCanvas';\n","import { N, W } from './directions';\n\nexport const canvasWidth = 800;\nexport const canvasHeight = 600;\n\n/* map */\nexport const tileWidth = 100;\nexport const tileHeight = 100;\nexport const mapWidth = 20;\nexport const mapHeight = 20;\nexport const mapPaddingX = 4;\nexport const mapPaddingY = 3;\n\n/* player */\nexport const playerStartCol = 5;\nexport const playerStartRow = 6;\nexport const playerStartDirection = N;\nexport const playerSpeed = 5;\n\n/* virus */\nexport const virusStartCol = 5;\nexport const virusStartRow = 4;\nexport const virusStartDirection = W;\nexport const virusSpeed = 2.5;\n\n/* colors */\nexport const lightGreen = '#75a042';\nexport const darkGreen = '#365b1d';\nexport const lightBlue = '#52638a';\nexport const darkBlue = '#2b3653';\nexport const lightRed = '#cd3926';\nexport const darkRed = '#7a2431';\n\nexport const collisionRadius = 30;\nexport const bombCooldown = 500;\n","export default () => {\n    const div = document.createElement('div');\n    div.style.cssText = `\n            position: absolute;\n            left: 0;\n            bottom: 0;\n            padding: 5px;\n            color: lime;\n            width: 100vw;\n            background-color: black;\n            font-family: monospace;\n        `;\n    document.body.appendChild(div);\n    window.devbox = div;\n};\n","export const N = 'N';\nexport const E = 'E';\nexport const S = 'S';\nexport const W = 'W';\n","import { directionSwitchMap, getNextTile, isValidTile } from '.';\n\nexport default (map, { x, y }, direction) => {\n    const tile = map.tileAtLayer('main', { x, y });\n    if (!isValidTile(tile) || !directionSwitchMap[tile].allowed.includes(direction)) {\n        return false;\n    }\n    const nextTile = getNextTile(map, { x, y }, direction);\n    return isValidTile(nextTile);\n};\n","import { N, E, S, W } from '.';\n\nexport default {\n    // curve from S to E\n    1: {\n        allowed: [S, E],\n        change: {\n            [N]: E,\n            [W]: S\n        }\n    },\n    // curve from W to S\n    2: {\n        allowed: [W, S],\n        change: {\n            [N]: W,\n            [E]: S\n        }\n    },\n    // straight from N to S\n    3: {\n        allowed: [N, S],\n        change: {}\n    },\n    // T section W, N, E\n    4: {\n        allowed: [W, N, E],\n        change: {\n            [S]: N\n        }\n    },\n    // T section N, E, S\n    5: {\n        allowed: [N, E, S],\n        change: {\n            [W]: E\n        }\n    },\n    // T section W, E, S\n    6: {\n        allowed: [W, E, S],\n        change: {\n            [N]: S\n        }\n    },\n    // curve from N to E\n    9: {\n        allowed: [N, E],\n        change: {\n            [S]: E,\n            [W]: N\n        }\n    },\n    // curve from W to N\n    10: {\n        allowed: [W, N],\n        change: {\n            [E]: N,\n            [S]: W\n        }\n    },\n    // straight from W to E\n    11: {\n        allowed: [W, E],\n        change: {}\n    },\n    // crossing\n    12: {\n        allowed: [N, E, S, W],\n        change: {}\n    },\n    // T section N, S, W\n    13: {\n        allowed: [N, S, W],\n        change: {\n            [E]: W\n        }\n    },\n    // server\n    14: {\n        allowed: [N, S],\n        change: {}\n    },\n    // terminus S\n    17: {\n        allowed: [S],\n        change: {\n            [N]: S\n        }\n    },\n    // terminus W\n    18: {\n        allowed: [W],\n        change: {\n            [E]: W\n        }\n    },\n    // terminus N\n    19: {\n        allowed: [N],\n        change: {\n            [S]: N\n        }\n    },\n    // terminus E\n    20: {\n        allowed: [E],\n        change: {\n            [W]: E\n        }\n    },\n    // broken server\n    38: {\n        allowed: [N, S],\n        change: {}\n    }\n};\n","import { N, E, S, W } from '.';\nimport { tileHeight, tileWidth } from '../config';\n\nexport default (map, { x, y }, direction) =>\n    map.tileAtLayer('main', {\n        x: direction === E ? x + tileWidth : direction === W ? x - tileWidth : x,\n        y: direction === N ? y - tileHeight : direction === S ? y + tileHeight : y\n    });\n","import { N, E, S, W } from '.';\n\nexport default direction => {\n    switch (direction) {\n        case N:\n            return S;\n        case E:\n            return W;\n        case S:\n            return N;\n        case W:\n            return W;\n        default:\n            return null;\n    }\n};\n","export * from './constants';\nexport { default as directionIsAllowed } from './directionIsAllowed';\nexport { default as switchDirection } from './switchDirection';\nexport { default as directionSwitchMap } from './directionSwitchMap';\nexport { default as isIntersection } from './isIntersection';\nexport { default as getOppositeDirection } from './getOppositeDirection';\nexport { default as getNextTile } from './getNextTile';\nexport { default as isValidTile } from './isValidTile';\n","import { directionSwitchMap } from './index';\n\nconst intersectionTiles = [];\nfor (const [tile, { allowed }] of Object.entries(directionSwitchMap)) {\n    if (allowed.length > 2) {\n        intersectionTiles.push(Number(tile));\n    }\n}\n\nexport default tile => intersectionTiles.includes(tile);\n","export default tile => tile < 25 || (tile > 30 && tile < 33) || (tile > 37 && tile < 41) || tile > 44;\n","import { directionSwitchMap, directionIsAllowed, isValidTile } from '.';\nimport { getRandomInt } from '../utils';\n\nexport default (map, { x, y }, curr) => {\n    const tile = map.tileAtLayer('main', { x, y });\n    /* player accidentally stepped onto a broken conduit tile */\n    if (!isValidTile(tile)) {\n        throw new Error('dropped');\n    }\n    const nextDirection = directionSwitchMap[tile].change[curr] || curr;\n    if (directionIsAllowed(map, { x, y }, nextDirection)) {\n        return nextDirection;\n    }\n    const otherDirections = directionSwitchMap[tile].allowed.filter(dir => directionIsAllowed(map, { x, y }, dir));\n    switch (otherDirections.length) {\n        case 0:\n            /* oh no, player locked themselves in! */\n            throw new Error('locked in');\n        case 1:\n            return otherDirections[0];\n        default:\n            return otherDirections[getRandomInt(0, otherDirections.length - 1)];\n    }\n};\n","/* global kontra */\n\nimport { createCanvas } from './canvas';\nimport { createLoop } from './loop';\nimport { createMap } from './map';\nimport { createPlayer } from './player';\nimport { Users } from './user';\nimport { createVirus } from './virus';\nimport { Bombs } from './bomb';\n\nif (process.env.NODE_ENV === 'development') {\n    require('./devbox/createDevbox').default();\n}\n\n(async () => {\n    createCanvas();\n    kontra.init();\n    const map = await createMap();\n    const player = createPlayer(map);\n    const virus = createVirus(map);\n    const bombs = new Bombs(map);\n    const users = new Users(map);\n    const loop = createLoop({ map, player, virus, users, bombs });\n    loop.start();\n})();\n","/* global kontra */\n\nimport { moveCamera } from './utils';\nimport { calculateRowAndCol } from '../utils';\nimport { pubsub, DROP_SHIP } from '../pubsub';\n\nexport default ({ map, player, virus, users, bombs }) => {\n    const times = [];\n    let fps;\n    let shipMoving = true;\n    pubsub.subscribe(DROP_SHIP, () => (shipMoving = false));\n\n    return kontra.gameLoop({\n        update() {\n            virus.update();\n            player.update();\n            player.infect(virus);\n            if (shipMoving) {\n                moveCamera(map, player.direction);\n            }\n            users.update();\n            users.infect([virus]);\n            bombs.update();\n        },\n        render() {\n            map.render();\n            users.render();\n            bombs.render();\n            player.render();\n            virus.render();\n            if (process.env.NODE_ENV === 'development') {\n                const now = performance.now();\n                while (times.length > 0 && times[0] <= now - 1000) {\n                    times.shift();\n                }\n                times.push(now);\n                fps = times.length;\n                const { row, col } = calculateRowAndCol(map);\n\n                // eslint-disable-next-line no-param-reassign\n                window.devbox.innerHTML = `${fps} fps â€“ sx=${map.sx}, sy=${map.sy}, row=${row}, col=${col}`;\n            }\n        }\n    });\n};\n","export { default as createLoop } from './createLoop';\n","export { default as moveCamera } from './moveCamera';\n","import { playerSpeed } from '../../config';\nimport { N, E, S, W } from '../../directions';\n\nexport default (map, direction) => {\n    switch (direction) {\n        case N:\n            // eslint-disable-next-line no-param-reassign\n            map.sy -= playerSpeed;\n            break;\n        case E:\n            // eslint-disable-next-line no-param-reassign\n            map.sx += playerSpeed;\n            break;\n        case S:\n            // eslint-disable-next-line no-param-reassign\n            map.sy += playerSpeed;\n            break;\n        case W:\n            // eslint-disable-next-line no-param-reassign\n            map.sx -= playerSpeed;\n            break;\n        default:\n    }\n};\n","/* global kontra */\n\nimport {\n    tileHeight,\n    tileWidth,\n    mapHeight as height,\n    mapWidth as width,\n    mapPaddingX,\n    mapPaddingY,\n    playerStartCol,\n    playerStartRow\n} from '../config';\nimport { calculateCameraCoordinates } from '../utils';\nimport mapData from './mapData';\nimport { addPadding } from './utils';\nimport { createTilesheet } from './tilesheet';\nimport { createTileEngine } from '../tileEngine';\n\nexport default async () => {\n    const { sx, sy } = calculateCameraCoordinates({ col: playerStartCol, row: playerStartRow });\n    const map = createTileEngine({\n        // tile size\n        tileWidth,\n        tileHeight,\n\n        // map size in tiles\n        width: width + mapPaddingX * 2,\n        height: height + mapPaddingY * 2,\n\n        sx,\n        sy\n    });\n\n    const paddedMap = addPadding(mapData, width, height, mapPaddingX, mapPaddingY);\n    const image = await createTilesheet();\n    map.addTilesets({ image });\n    // map.addTilesets({ image: kontra.assets.images.tilesheet });\n    map.addLayers([\n        {\n            name: 'main',\n            data: paddedMap\n        },\n        {\n            name: 'debug',\n            data: new Array(paddedMap.length).fill(0)\n        }\n        // {\n        //     name: 'grid',\n        //     data: new Array(paddedMap.length).fill(8)\n        // }\n    ]);\n    return map;\n};\n","export { default as createMap } from './createMap';\n","// prettier-ignore\nexport default [\n    0, 17,  0,  0,  0, 17,  0,  0,  0, 17,  0,  0,  0, 17,  0,  0,  0, 17,  0,  0,\n   20,  4, 11,  2,  1,  4,  2,  0,  0,  5, 11,  6, 11, 13,  0,  1, 11, 12,  2,  0,\n    0,  1, 11, 10,  9, 11, 13,  0,  0,  3,  0,  3,  0,  5, 11, 13,  0,  3,  3,  0,\n    0,  3,  1, 11,  6, 11, 10,  0,  1,  4,  2,  9, 11, 13,  0,  9, 11, 10,  3,  0,\n    0,  3,  3,  0,  3,  0,  0,  0,  3,  1, 13,  0,  0,  3,  0,  0,  0,  0,  5, 18,\n    0,  3,  3,  0, 14,  0,  1, 11, 10,  3,  9, 11,  6,  4, 11,  6,  2,  0,  3,  0,\n    0,  3,  3,  0,  3,  0,  3,  0,  0,  3,  0,  0,  3,  0,  0,  3,  3,  0,  3,  0,\n    0,  9, 13,  0,  5, 11, 10,  0,  0,  3,  1, 11, 10,  0,  0,  3,  3,  0,  3,  0,\n    0,  0,  3,  0,  3,  0,  0,  0,  1,  4, 10,  0,  0,  0,  0,  3,  5, 11,  4, 18,\n    0,  1, 13,  0,  5, 11,  2,  0,  3,  0,  1, 11, 11, 11, 11, 12, 10,  0,  0,  0,\n    0,  3,  3,  0,  3,  0,  5, 11, 13,  0,  9, 11,  2,  0,  0,  3,  0,  0,  1, 18,\n    0,  9, 10,  0,  5, 11, 10,  0,  9, 11, 11, 11, 12, 11,  6, 10,  0,  0,  3,  0,\n    0,  0,  0,  0,  3,  1, 11,  2,  1, 11, 11, 11, 10,  0,  3,  0,  1, 11,  4, 18,\n   20,  6,  6, 11, 10,  3,  0,  3,  3,  0,  0,  0,  1,  2,  9, 11, 12, 11,  2,  0,\n    0,  3,  3,  0,  0,  3,  0,  3,  3,  1, 11,  2,  3,  3,  0,  0,  3,  0,  3,  0,\n    0,  5,  4,  2,  0,  5, 11, 10,  3,  3,  0,  5, 12,  4, 11, 11, 13,  0,  5, 18,\n    0,  3,  0,  5, 11, 12, 11,  6, 10,  9,  6, 10,  3,  0,  0,  0,  9, 11, 10,  0,\n   20,  4, 11, 13,  0,  3,  0,  9, 11, 11, 13,  0,  9, 11,  6, 11,  6,  6, 11, 18,\n    0,  0,  0,  3,  0,  3,  0,  0,  0,  0,  5, 11, 11,  2,  3,  0,  3,  3,  0,  0,\n    0,  0,  0, 19,  0, 19,  0,  0,  0,  0, 19,  0,  0, 19,  9, 11, 10, 19,  0,  0\n];\n","import { tileHeight, tileWidth } from '../../config';\nimport { drawCurve, drawStraight, drawTSection, drawCrossing, drawServer, drawTerminus } from '.';\n\nexport default () => {\n    const canvas = document.createElement('canvas');\n    canvas.width = 8 * tileWidth;\n    canvas.height = 8 * tileHeight;\n    const ctx = canvas.getContext('2d');\n    drawCurve({ ctx, row: 1, col: 1, deg: 0 });\n    drawCurve({ ctx, row: 1, col: 2, deg: 90 });\n    drawCurve({ ctx, row: 2, col: 1, deg: 270 });\n    drawCurve({ ctx, row: 2, col: 2, deg: 180 });\n    drawStraight({ ctx, row: 1, col: 3, deg: 0 });\n    drawStraight({ ctx, row: 2, col: 3, deg: 90 });\n    drawTSection({ ctx, row: 1, col: 4, deg: 0 });\n    drawTSection({ ctx, row: 1, col: 5, deg: 90 });\n    drawTSection({ ctx, row: 1, col: 6, deg: 180 });\n    drawTSection({ ctx, row: 2, col: 5, deg: 270 });\n    drawCrossing({ ctx, row: 2, col: 4 });\n    drawTerminus({ ctx, row: 3, col: 1, deg: 0 });\n    drawTerminus({ ctx, row: 3, col: 2, deg: 90 });\n    drawTerminus({ ctx, row: 3, col: 3, deg: 180 });\n    drawTerminus({ ctx, row: 3, col: 4, deg: 270 });\n    drawServer({ ctx, row: 2, col: 6 });\n    drawCurve({ ctx, row: 4, col: 1, deg: 0, broken: true });\n    drawCurve({ ctx, row: 4, col: 2, deg: 90, broken: true });\n    drawCurve({ ctx, row: 5, col: 1, deg: 270, broken: true });\n    drawCurve({ ctx, row: 5, col: 2, deg: 180, broken: true });\n    drawStraight({ ctx, row: 4, col: 3, deg: 0, broken: true });\n    drawStraight({ ctx, row: 5, col: 3, deg: 90, broken: true });\n    drawTSection({ ctx, row: 4, col: 4, deg: 0, broken: true });\n    drawTSection({ ctx, row: 4, col: 5, deg: 90, broken: true });\n    drawTSection({ ctx, row: 4, col: 6, deg: 180, broken: true });\n    drawTSection({ ctx, row: 5, col: 5, deg: 270, broken: true });\n    drawCrossing({ ctx, row: 5, col: 4, broken: true });\n    drawTerminus({ ctx, row: 6, col: 1, deg: 0, broken: true });\n    drawTerminus({ ctx, row: 6, col: 2, deg: 90, broken: true });\n    drawTerminus({ ctx, row: 6, col: 3, deg: 180, broken: true });\n    drawTerminus({ ctx, row: 6, col: 4, deg: 270, broken: true });\n    drawServer({ ctx, row: 5, col: 6, broken: true });\n    if (process.env.NODE_ENV === 'development') {\n        require('./drawDebugGrid').default({ ctx, row: 1, col: 8 });\n    }\n    const image = new Image();\n    image.src = canvas.toDataURL('image/png');\n    // document.getElementById('wrapper').appendChild(image);\n    return new Promise(resolve => setTimeout(() => resolve(image), 100));\n};\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config';\nimport { krakel } from './utils';\n\nexport default ({ ctx, row, col, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        krakel(ctx, [\n            [0, -20, 50],\n            [1, -20, 45],\n            [1, -10, 40],\n            [1, 0, 45],\n            [1, 10, 35],\n            [1, 20, 40],\n            [1, 20, 50],\n            [0, 50, 20],\n            [1, 40, 20],\n            [1, 45, 10],\n            [1, 40, -10],\n            [1, 45, -20],\n            [1, 50, -20],\n            [0, 20, -50],\n            [1, 20, -35],\n            [1, 10, -40],\n            [1, 0, -30],\n            [1, -10, -40],\n            [1, -20, -35],\n            [1, -20, -50],\n            [0, -50, -20],\n            [1, -40, -20],\n            [1, -35, -10],\n            [1, -45, 0],\n            [1, -30, 10],\n            [1, -35, 20],\n            [1, -50, 20]\n        ]);\n    } else {\n        krakel(ctx, [\n            [0, -20, -50],\n            [1, -20, -20],\n            [1, -50, -20],\n            [0, 20, -50],\n            [1, 20, -20],\n            [1, 50, -20],\n            [0, -50, 20],\n            [1, -20, 20],\n            [1, -20, 50],\n            [0, 50, 20],\n            [1, 20, 20],\n            [1, 20, 50]\n        ]);\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","/* eslint-disable no-param-reassign */\nimport { degreesToRadians as deg2rad } from '../../utils';\nimport { tileHeight, tileWidth, lightBlue } from '../../config';\n\nfunction calculatePointOnArc(deg, r) {\n    return [Math.cos(deg2rad(deg)) * r + 50, Math.sin(deg2rad(deg)) * r + 50];\n}\n\nexport default ({ ctx, row, col, deg, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.rotate(deg2rad(deg));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        ctx.moveTo(20, 50);\n        ctx.arc(50, 50, 30, deg2rad(180), deg2rad(190));\n        ctx.moveTo(...calculatePointOnArc(190, 30));\n        ctx.lineTo(10, 45);\n        ctx.lineTo(10, 35);\n        ctx.lineTo(-10, 40);\n        ctx.lineTo(...calculatePointOnArc(190, 70));\n        ctx.arc(50, 50, 70, deg2rad(190), deg2rad(180), true);\n        ctx.moveTo(50, 20);\n        ctx.arc(50, 50, 30, deg2rad(270), deg2rad(260), true);\n        ctx.moveTo(...calculatePointOnArc(260, 30));\n        ctx.lineTo(40, 10);\n        ctx.lineTo(45, 0);\n        ctx.lineTo(35, 0);\n        ctx.lineTo(...calculatePointOnArc(260, 70));\n        ctx.arc(50, 50, 70, deg2rad(260), deg2rad(270));\n    } else {\n        ctx.moveTo(20, 50);\n        ctx.arc(50, 50, 30, deg2rad(180), deg2rad(270));\n        ctx.moveTo(-20, 50);\n        ctx.arc(50, 50, 70, deg2rad(180), deg2rad(270));\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight } from '../../config';\n\nexport default ({ ctx, row, col }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.moveTo(-49, -49);\n    ctx.lineTo(50, -49);\n    ctx.lineTo(50, 50);\n    ctx.lineTo(-49, 50);\n    ctx.lineTo(-49, -49);\n    ctx.stroke();\n    ctx.restore();\n};\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config';\nimport { krakel } from './utils';\n\nexport default ({ ctx, row, col, broken }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    krakel(ctx, [\n        [0, 30, -48],\n        [1, 48, -30],\n        [1, 48, 30],\n        [1, 30, 48],\n        [1, -30, 48],\n        [1, -48, 30],\n        [1, -48, -30],\n        [1, -30, -48],\n        [1, 30, -48]\n    ]);\n    ctx.stroke();\n    if (broken) {\n        ctx.lineWidth = 2;\n        krakel(ctx, [\n            [0, 10, -48],\n            [1, 0, -40],\n            [0, 24, -48],\n            [1, 20, -30],\n            [0, 48, -27],\n            [1, 20, -20],\n            [0, -10, -30],\n            [1, 10, -30],\n            [1, 30, -10],\n            [1, 20, 0],\n            [1, 10, 0],\n            [0, 48, 7],\n            [1, 30, 10],\n            [0, 20, 0],\n            [1, 30, 10],\n            [1, 10, 20],\n            [0, 30, 48],\n            [1, 30, 30],\n            [1, 10, 30],\n            [0, 20, 20],\n            [1, 20, 30],\n            [0, -10, 48],\n            [1, -10, 20],\n            [1, 0, 10],\n            [0, -20, 0],\n            [1, -20, 20],\n            [1, -10, 30],\n            [0, -30, 48],\n            [1, -20, 40],\n            [1, -20, 30],\n            [0, -30, 30],\n            [1, -20, 40],\n            [0, -48, 20],\n            [1, -30, 20],\n            [0, -40, 20],\n            [1, -40, 10],\n            [0, -48, 0],\n            [1, -30, 0],\n            [1, -20, -10],\n            [0, -40, 0],\n            [1, -30, 10],\n            [0, -48, -17],\n            [1, -40, -30],\n            [1, -30, -20],\n            [0, -30, -48],\n            [1, -10, -20],\n            [1, -10, -10],\n            [0, -20, -30],\n            [1, -20, -20],\n            [1, -30, -10]\n        ]);\n        ctx.stroke();\n    }\n    ctx.restore();\n};\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config';\nimport { degreesToRadians as deg2rad } from '../../utils';\nimport { krakel } from './utils';\n\nexport default ({ ctx, row, col, deg, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.rotate(deg2rad(deg));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        krakel(ctx, [\n            [0, -20, 50],\n            [1, -20, 30],\n            [1, -10, 40],\n            [1, 0, 25],\n            [1, 10, 35],\n            [1, 20, 30],\n            [1, 20, 50],\n            [0, -20, -50],\n            [1, -20, -40],\n            [1, -10, -25],\n            [1, 0, -35],\n            [1, 10, -30],\n            [1, 20, -40],\n            [1, 20, -50]\n        ]);\n    } else {\n        krakel(ctx, [[0, -20, -50], [1, -20, 50], [0, 20, -50], [1, 20, 50]]);\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config';\nimport { degreesToRadians as deg2rad } from '../../utils';\nimport { krakel } from './utils';\n\nexport default ({ ctx, row, col, deg, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.rotate(deg2rad(deg));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        krakel(ctx, [\n            [0, 50, 20],\n            [1, 40, 20],\n            [1, 45, 10],\n            [1, 40, -10],\n            [1, 45, -20],\n            [1, 50, -20],\n            [0, 20, -50],\n            [1, 20, -35],\n            [1, 10, -40],\n            [1, 0, -30],\n            [1, -10, -40],\n            [1, -20, -35],\n            [1, -20, -50],\n            [0, -50, -20],\n            [1, -40, -20],\n            [1, -35, -10],\n            [1, -45, 0],\n            [1, -30, 10],\n            [1, -35, 20],\n            [1, -50, 20]\n        ]);\n    } else {\n        krakel(ctx, [\n            [0, -20, -50],\n            [1, -20, -20],\n            [1, -50, -20],\n            [0, 20, -50],\n            [1, 20, -20],\n            [1, 50, -20],\n            [0, -50, 20],\n            [1, 50, 20]\n        ]);\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","/* eslint-disable no-param-reassign */\nimport { tileWidth, tileHeight, lightBlue } from '../../config';\nimport { degreesToRadians as deg2rad } from '../../utils';\nimport { krakel } from './utils';\n\nexport default ({ ctx, row, col, deg, broken = false }) => {\n    ctx.save();\n    ctx.translate((col - 1) * tileWidth + tileWidth / 2, (row - 1) * tileHeight + tileHeight / 2);\n    ctx.rotate(deg2rad(deg));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightBlue;\n    ctx.beginPath();\n    if (broken) {\n        krakel(ctx, [[0, -20, 50], [1, -20, 40], [1, -10, 45], [1, 0, 35], [1, 10, 45], [1, 20, 40], [1, 20, 50]]);\n    } else {\n        krakel(ctx, [[0, -20, 50], [1, -20, 0], [1, 20, 0], [1, 20, 50]]);\n    }\n    ctx.stroke();\n    ctx.restore();\n};\n","export { default as createTilesheet } from './createTilesheet';\nexport { default as drawCurve } from './drawCurve';\nexport { default as drawStraight } from './drawStraight';\nexport { default as drawTSection } from './drawTSection';\nexport { default as drawCrossing } from './drawCrossing';\nexport { default as drawServer } from './drawServer';\nexport { default as drawTerminus } from './drawTerminus';\n","export { default as krakel } from './krakel';\n","/* creates canvas moveTo and lineTo commands from arrays; doing this mostly to save a couple of bytes */\nexport default (ctx, data) => data.forEach(([draw, x, y]) => ctx[draw ? 'lineTo' : 'moveTo'](x, y));\n","export default (arr, w, h, x, y) => {\n    const retVal = [];\n    let idx = 0;\n    for (let row = 0; row < h + y * 2; row++) {\n        for (let col = 0; col < w + x * 2; col++) {\n            if (row < y || row >= y + h || col < x || col >= x + w) {\n                retVal.push(0);\n                continue;\n            }\n            retVal.push(arr[idx++]);\n        }\n    }\n    return retVal;\n};\n","export { default as addPadding } from './addPadding';\n","export { default as messageBox } from './messageBox';\n","class MessageBox {\n    constructor() {\n        this.timeoutHandler = null;\n        this.div = document.createElement('div');\n        this.div.style.cssText = `\nbackground-color: rgba(0,0,0,0);\nfont-size: 3em;\nfont-weight: bold;\nalign-items: center;\njustify-content: center;\ndisplay: flex;\ncolor: rgba(255,255,255,0);\nposition: absolute;\ntop: 0;\nleft:0;\nwidth: 100vw;\nheight: 100vh;\ntext-align: center;\npointer-events: none;\ntransition: background-color 3s ease-out, color 3s ease-out;\ntext-transform: uppercase;\nfont-family: monospace;\n    `;\n        const wrapper = document.getElementById('wrapper');\n        wrapper.appendChild(this.div);\n    }\n\n    show(message) {\n        clearTimeout(this.timeoutHandler);\n        this.div.style.transition = '3s';\n        this.div.innerHTML = `<div>${message}</div>`;\n        this.div.style.backgroundColor = 'rgba(0,0,0,0.5)';\n        this.div.style.color = 'rgba(255,255,255,1)';\n    }\n\n    flash(message) {\n        clearTimeout(this.timeoutHandler);\n        this.div.style.transition = '0.5s';\n        this.div.innerHTML = `<div>${message}</div>`;\n        this.div.style.color = 'rgba(255,255,255,1)';\n        this.timeoutHandler = setTimeout(() => (this.div.style.color = 'rgba(255,255,255,0)'), 500);\n    }\n}\nexport default new MessageBox();\n","/* global kontra */\n\nimport { drawPlayer, updatePlayer } from '.';\nimport { canvasHeight, canvasWidth, playerStartDirection, collisionRadius } from '../config';\nimport { pubsub, GAME_OVER, DROP_SHIP } from '../pubsub';\nimport { collides } from '../utils';\nimport { messageBox } from '../messageBox';\n\nexport default map => {\n    const player = kontra.sprite({\n        x: canvasWidth / 2,\n        y: canvasHeight / 2,\n        collisionRadius,\n        map,\n        infected: false,\n        gameOver: false,\n        direction: playerStartDirection,\n        nextDirection: null,\n        dropBomb: false,\n        scale: 1,\n        dropping: false,\n        bombCoolingDown: false,\n\n        update() {\n            ({\n                nextDirection: this.nextDirection,\n                direction: this.direction,\n                dropBomb: this.dropBomb,\n                scale: this.scale,\n                bombCoolingDown: this.bombCoolingDown\n            } = updatePlayer(this, pubsub, messageBox));\n        },\n\n        render() {\n            drawPlayer(this);\n        },\n\n        infect(virus) {\n            if (collides(virus, this)) {\n                // eslint-disable-next-line no-param-reassign\n                this.infected = true;\n                if (!this.gameOver) {\n                    messageBox.show('player infected<br>game over');\n                    pubsub.publish(GAME_OVER);\n                }\n            }\n        }\n    });\n\n    pubsub.subscribe(GAME_OVER, () => (player.gameOver = true));\n    pubsub.subscribe(DROP_SHIP, () => (player.dropping = true));\n\n    return player;\n};\n","import { lightGreen, darkGreen, lightRed, darkRed } from '../config';\nimport { calculateRotation } from '../utils';\n\nexport default sprite => {\n    const { context: ctx, x, y, direction, infected, scale } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.scale(scale, scale);\n    ctx.rotate(calculateRotation(direction));\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = infected ? lightRed : lightGreen;\n    ctx.fillStyle = infected ? darkRed : darkGreen;\n    ctx.beginPath();\n    ctx.moveTo(-15, 25);\n    ctx.lineTo(0, -25);\n    ctx.lineTo(15, 25);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n};\n","export { default as createPlayer } from './createPlayer';\nexport { default as drawPlayer } from './drawPlayer';\nexport { default as updatePlayer } from './updatePlayer';\n","import { directionIsAllowed, switchDirection } from '../directions';\nimport { pubsub, DROP_BOMB, DROP_SHIP, GAME_OVER } from '../pubsub';\nimport { getKey, isInTheMiddle } from './utils';\nimport { calculateRowAndCol } from '../utils';\nimport { messageBox } from '../messageBox';\nimport { bombCooldown } from '../config';\n\nexport default sprite => {\n    let { nextDirection, direction, dropBomb, scale, bombCoolingDown } = sprite;\n    const { dropping } = sprite;\n    if (dropping) {\n        if (scale > 0) {\n            scale -= 0.01;\n        } else {\n            messageBox.show('You fell into the abyss<br>Game over');\n            pubsub.publish(GAME_OVER);\n        }\n        return { direction, nextDirection, dropBomb, scale, bombCoolingDown };\n    }\n    const { map, x, y, gameOver } = sprite;\n    if (!gameOver) {\n        ({ nextDirection, dropBomb } = getKey(sprite));\n        if (bombCoolingDown) {\n            dropBomb = false;\n        }\n    }\n    if (!isInTheMiddle({ x: map.sx, y: map.sy })) {\n        return { direction, nextDirection, dropBomb, scale, bombCoolingDown };\n    }\n    if (nextDirection && directionIsAllowed(map, { x, y }, nextDirection)) {\n        direction = nextDirection;\n        nextDirection = null;\n    } else {\n        try {\n            direction = switchDirection(map, { x, y }, direction);\n        } catch ({ message }) {\n            if (message === 'dropped') {\n                pubsub.publish(DROP_SHIP);\n            }\n        }\n    }\n    if (dropBomb) {\n        pubsub.publish(DROP_BOMB, calculateRowAndCol(map));\n        dropBomb = false;\n        bombCoolingDown = true;\n        setTimeout(() => {\n            // eslint-disable-next-line no-param-reassign\n            sprite.bombCoolingDown = false;\n        }, bombCooldown);\n    }\n    return { direction, nextDirection, dropBomb, scale, bombCoolingDown };\n};\n","/* global kontra */\n\nimport { N, E, S, W } from '../../directions';\n\nexport default sprite => {\n    let { nextDirection, dropBomb } = sprite;\n    if (kontra.keys.pressed('right')) {\n        nextDirection = E;\n    }\n    if (kontra.keys.pressed('left')) {\n        nextDirection = W;\n    }\n    if (kontra.keys.pressed('up')) {\n        nextDirection = N;\n    }\n    if (kontra.keys.pressed('down')) {\n        nextDirection = S;\n    }\n    if (kontra.keys.pressed('space')) {\n        dropBomb = true;\n    }\n    return { nextDirection, dropBomb };\n};\n","export { default as isInTheMiddle } from './isInTheMiddle';\nexport { default as getKey } from './getKey';\n","import { tileHeight, tileWidth } from '../../config';\n\nexport default ({ x, y }) => (x - tileWidth / 2) % tileWidth === 0 && (y - tileHeight / 2) % tileHeight === 0;\n","export const GAME_OVER = 0;\nexport const DROP_BOMB = 1;\nexport const DROP_SHIP = 2;\n","export { default as pubsub } from './pubsub';\nexport * from './constants';\n","// exported for testing\nexport class Pubsub {\n    constructor() {\n        this.subscribers = [];\n    }\n    subscribe(message, callback) {\n        this.subscribers.push({ message, callback });\n    }\n    publish(incomingMessage, payload) {\n        this.subscribers.forEach(({ message, callback }) => message === incomingMessage && callback(payload));\n    }\n}\n\nexport default new Pubsub();\n","/* global kontra */\nimport { flatIndex } from './utils';\n\n/**\n * A tile engine for rendering tilesets. Works well with the tile engine program Tiled.\n * @memberof kontra\n *\n * @param {object} properties - Properties of the tile engine.\n * @param {number} [properties.tileWidth=32] - Width of a tile.\n * @param {number} [properties.tileHeight=32] - Height of a tile.\n * @param {number} properties.width - Width of the map (in tiles).\n * @param {number} properties.height - Height of the map (in tiles).\n * @param {number} [properties.x=0] - X position to draw.\n * @param {number} [properties.y=0] - Y position to draw.\n * @param {number} [properties.sx=0] - X position to clip the tileset.\n * @param {number} [properties.sy=0] - Y position to clip the tileset.\n * @param {Context} [properties.context=kontra.context] - Provide a context for the tile engine to draw on.\n */\nexport default (properties = {}) => {\n    // size of the map (in tiles)\n    // @if DEBUG\n    if (!properties.width || !properties.height) {\n        throw Error('You must provide width and height properties');\n    }\n    // @endif\n    const width = properties.width;\n    const height = properties.height;\n\n    // size of the tiles. Most common tile size on opengameart.org seems to be 32x32,\n    // followed by 16x16\n    // Tiled names the property tilewidth and tileheight\n    const tileWidth = properties.tileWidth || 32;\n    const tileHeight = properties.tileHeight || 32;\n\n    const mapWidth = width * tileWidth;\n    const mapHeight = height * tileHeight;\n\n    const context = properties.context || kontra.context;\n    const canvasWidth = context.canvas.width;\n    const canvasHeight = context.canvas.height;\n\n    // create an off-screen canvas for pre-rendering the map\n    // @see http://jsperf.com/render-vs-prerender\n    const offscreenCanvas = document.createElement('canvas');\n    const offscreenContext = offscreenCanvas.getContext('2d');\n\n    // when clipping an image, sx and sy must within the image region, otherwise\n    // Firefox and Safari won't draw it.\n    // @see http://stackoverflow.com/questions/19338032/canvas-indexsizeerror-index-or-size-is-negative-or-greater-than-the-allowed-a\n    const sxMax = Math.max(0, mapWidth - canvasWidth);\n    const syMax = Math.max(0, mapHeight - canvasHeight);\n\n    let _sx, _sy;\n\n    // draw order of layers (by name)\n    const layerOrder = [];\n\n    const tileEngine = {\n        width,\n        height,\n\n        tileWidth,\n        tileHeight,\n\n        mapWidth,\n        mapHeight,\n\n        context,\n\n        x: properties.x || 0,\n        y: properties.y || 0,\n\n        tilesets: [],\n        layers: {},\n\n        /**\n         * Add an tileset for the tile engine to use.\n         * @memberof kontra.tileEngine\n         */\n        addTilesets: function addTilesets(tilesets) {\n            [].concat(tilesets).forEach(tileset => {\n                const tilesetImage = tileset.image;\n                let image, firstGrid, lastTileset, tiles;\n\n                // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types\n                if (`${tilesetImage}` === tilesetImage) {\n                    let i = Infinity;\n\n                    while (i >= 0) {\n                        i = tilesetImage.lastIndexOf('/', i);\n                        const path = i < 0 ? tilesetImage : tilesetImage.substr(i);\n\n                        if (kontra.assets.images[path]) {\n                            image = kontra.assets.images[path];\n                            break;\n                        }\n\n                        i--;\n                    }\n                } else {\n                    image = tilesetImage;\n                }\n\n                firstGrid = tileset.firstGrid;\n\n                // if the width or height of the provided image is smaller than the tile size,\n                // default calculation to 1\n                const numTiles = ((image.width / tileWidth) | 0 || 1) * ((image.height / tileHeight) | 0 || 1);\n\n                if (!firstGrid) {\n                    // only calculate the first grid if the tile map has a tileset already\n                    if (tileEngine.tilesets.length > 0) {\n                        lastTileset = tileEngine.tilesets[tileEngine.tilesets.length - 1];\n                        tiles =\n                            ((lastTileset.image.width / tileWidth) | 0) * ((lastTileset.image.height / tileHeight) | 0);\n\n                        firstGrid = lastTileset.firstGrid + tiles;\n                    }\n                    // otherwise this is the first tile added to the tile map\n                    else {\n                        firstGrid = 1;\n                    }\n                }\n\n                tileEngine.tilesets.push({\n                    firstGrid,\n                    lastGrid: firstGrid + numTiles - 1,\n                    image\n                });\n\n                // sort the tile map so we can perform a binary search when drawing\n                tileEngine.tilesets.sort((a, b) => a.firstGrid - b.firstGrid);\n            });\n        },\n\n        /**\n         * Add a layer to the tile engine.\n         * @memberof kontra.tileEngine\n         */\n        addLayers: function addLayers(layers) {\n            [].concat(layers).forEach(layer => {\n                // eslint-disable-next-line no-param-reassign\n                layer.render = layer.render === undefined ? true : layer.render;\n\n                let data, row, c, value;\n\n                // flatten a 2D array into a single array\n                if (Array.isArray(layer.data[0])) {\n                    data = [];\n\n                    // eslint-disable-next-line no-cond-assign\n                    for (let r = 0; (row = layer.data[r]); r++) {\n                        for (c = 0; c < width; c++) {\n                            data.push(row[c] || 0);\n                        }\n                    }\n                } else {\n                    data = layer.data;\n                }\n\n                tileEngine.layers[layer.name] = {\n                    data,\n                    zIndex: layer.zIndex || 0,\n                    render: layer.render\n                };\n\n                // merge properties of layer onto layer object\n                for (const prop in layer.properties) {\n                    if (layer.properties.hasOwnProperty(prop)) {\n                        value = layer.properties[prop];\n\n                        try {\n                            value = JSON.parse(value);\n                        } catch (e) {\n                            /* intentionally empty */\n                        }\n\n                        tileEngine.layers[layer.name][prop] = value;\n                    }\n                }\n\n                // only add the layer to the layer order if it should be drawn\n                if (tileEngine.layers[layer.name].render) {\n                    layerOrder.push(layer.name);\n\n                    layerOrder.sort((a, b) => tileEngine.layers[a].zIndex - tileEngine.layers[b].zIndex);\n                }\n            });\n\n            preRenderImage();\n        },\n\n        changeTile(layerId, { row, col }, tile) {\n            const dataIndex = flatIndex(row, col, width);\n            const layer = tileEngine.layers[layerId];\n            layer.data[dataIndex] = tile;\n            renderTile(layer, dataIndex, true);\n        },\n\n        /**\n         * Simple bounding box collision test for layer tiles.\n         * @memberof kontra.tileEngine\n         *\n         * @param {string} name - Name of the layer.\n         * @param {object} object - Object to check collision against.\n         * @param {number} object.x - X coordinate of the object.\n         * @param {number} object.y - Y coordinate of the object.\n         * @param {number} object.width - Width of the object.\n         * @param {number} object.height - Height of the object.\n         *\n         * @returns {boolean} True if the object collides with a tile, false otherwise.\n         */\n        layerCollidesWith: function layerCollidesWith(name, object) {\n            // calculate all tiles that the object can collide with\n            const row = tileEngine.getRow(object.y);\n            const col = tileEngine.getCol(object.x);\n\n            const endRow = tileEngine.getRow(object.y + object.height);\n            const endCol = tileEngine.getCol(object.x + object.width);\n\n            // check all tiles\n            let index;\n            for (let r = row; r <= endRow; r++) {\n                for (let c = col; c <= endCol; c++) {\n                    index = getIndex({ row: r, col: c });\n\n                    if (tileEngine.layers[name].data[index]) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        },\n\n        /**\n         * Get the tile from the specified layer at x, y or row, col.\n         * @memberof kontra.tileEngine\n         *\n         * @param {string} name - Name of the layer.\n         * @param {object} position - Position of the tile in either x, y or row, col.\n         * @param {number} position.x - X coordinate of the tile.\n         * @param {number} position.y - Y coordinate of the tile.\n         * @param {number} position.row - Row of the tile.\n         * @param {number} position.col - Col of the tile.\n         *\n         * @returns {number}\n         */\n        tileAtLayer(name, position) {\n            const index = getIndex(position);\n\n            if (index >= 0) {\n                return tileEngine.layers[name].data[index];\n            }\n            return undefined;\n        },\n\n        /**\n         * Render the pre-rendered canvas.\n         * @memberof kontra.tileEngine\n         */\n        render() {\n            tileEngine.context.drawImage(\n                offscreenCanvas,\n                tileEngine.sx,\n                tileEngine.sy,\n                canvasWidth,\n                canvasHeight,\n                tileEngine.x,\n                tileEngine.y,\n                canvasWidth,\n                canvasHeight\n            );\n        },\n\n        /**\n         * Render a specific layer.\n         * @memberof kontra.tileEngine\n         *\n         * @param {string} name - Name of the layer to render.\n         */\n        renderLayer: function renderLayer(name) {\n            const layer = tileEngine.layers[name];\n\n            // calculate the starting tile\n            let row = tileEngine.getRow();\n            const col = tileEngine.getCol();\n            let index = getIndex({ row, col });\n\n            // calculate where to start drawing the tile relative to the drawing canvas\n            const startX = col * tileWidth - tileEngine.sx;\n            const startY = row * tileHeight - tileEngine.sy;\n\n            // calculate how many tiles the drawing canvas can hold\n            const viewWidth = Math.min(Math.ceil(canvasWidth / tileWidth) + 1, width);\n            const viewHeight = Math.min(Math.ceil(canvasHeight / tileHeight) + 1, height);\n            const numTiles = viewWidth * viewHeight;\n\n            let count = 0;\n            let x, y, tile, tileset, image, tileOffset, w, sx, sy;\n\n            // draw just enough of the layer to fit inside the drawing canvas\n            while (count < numTiles) {\n                tile = layer.data[index];\n\n                if (tile) {\n                    tileset = getTileset(tile);\n                    image = tileset.image;\n\n                    x = startX + (count % viewWidth) * tileWidth;\n                    y = startY + ((count / viewWidth) | 0) * tileHeight;\n\n                    tileOffset = tile - tileset.firstGrid;\n                    w = image.width / tileWidth;\n\n                    sx = (tileOffset % w) * tileWidth;\n                    sy = ((tileOffset / w) | 0) * tileHeight;\n\n                    tileEngine.context.drawImage(image, sx, sy, tileWidth, tileHeight, x, y, tileWidth, tileHeight);\n                }\n\n                if (++count % viewWidth === 0) {\n                    index = col + ++row * width;\n                } else {\n                    index++;\n                }\n            }\n        },\n\n        /**\n         * Get the row from the y coordinate.\n         * @memberof kontra.tileEngine\n         *\n         * @param {number} y - Y coordinate.\n         *\n         * @return {number}\n         */\n        getRow(y) {\n            // eslint-disable-next-line no-param-reassign\n            y = y || 0;\n\n            return ((tileEngine.sy + y) / tileHeight) | 0;\n        },\n\n        /**\n         * Get the col from the x coordinate.\n         * @memberof kontra.tileEngine\n         *\n         * @param {number} x - X coordinate.\n         *\n         * @return {number}\n         */\n        getCol(x) {\n            // eslint-disable-next-line no-param-reassign\n            x = x || 0;\n\n            return ((tileEngine.sx + x) / tileWidth) | 0;\n        },\n\n        get sx() {\n            return _sx;\n        },\n\n        get sy() {\n            return _sy;\n        },\n\n        // ensure sx and sy are within the image region\n        set sx(value) {\n            _sx = Math.min(Math.max(0, value), sxMax);\n        },\n\n        set sy(value) {\n            _sy = Math.min(Math.max(0, value), syMax);\n        },\n\n        // expose properties for testing\n        // @if DEBUG\n        _layerOrder: layerOrder\n        // @endif\n    };\n\n    // set here so we use setter function\n    tileEngine.sx = properties.sx || 0;\n    tileEngine.sy = properties.sy || 0;\n\n    // make the off-screen canvas the full size of the map\n    offscreenCanvas.width = mapWidth;\n    offscreenCanvas.height = mapHeight;\n\n    // merge properties of the tile engine onto the tile engine itself\n    for (const prop in properties.properties) {\n        if (properties.properties.hasOwnProperty(prop)) {\n            let value = properties.properties[prop];\n\n            try {\n                value = JSON.parse(value);\n            } catch (e) {\n                /* intentionally empty */\n            }\n\n            // passed in properties override properties.properties\n            tileEngine[prop] = tileEngine[prop] || value;\n        }\n    }\n\n    if (properties.tilesets) {\n        tileEngine.addTilesets(properties.tilesets);\n    }\n\n    if (properties.layers) {\n        tileEngine.addLayers(properties.layers);\n    }\n\n    /**\n     * Get the index of the x, y or row, col.\n     * @memberof kontra.tileEngine\n     * @private\n     *\n     * @param {number} position.x - X coordinate of the tile.\n     * @param {number} position.y - Y coordinate of the tile.\n     * @param {number} position.row - Row of the tile.\n     * @param {number} position.col - Col of the tile.\n     *\n     * @return {number} Returns the tile index or -1 if the x, y or row,\n     *         col is outside the dimensions of the tile engine.\n     */\n    function getIndex(position) {\n        let row, col;\n\n        if (typeof position.x !== 'undefined' && typeof position.y !== 'undefined') {\n            row = tileEngine.getRow(position.y);\n            col = tileEngine.getCol(position.x);\n        } else {\n            row = position.row;\n            col = position.col;\n        }\n\n        // don't calculate out of bound numbers\n        if (row < 0 || col < 0 || row >= height || col >= width) {\n            return -1;\n        }\n\n        return col + row * width;\n    }\n\n    /**\n     * Modified binary search that will return the tileset associated with the tile\n     * @memberof kontra.tileEngine\n     * @private\n     *\n     * @param {number} tile - Tile grid.\n     *\n     * @return {object}\n     */\n    function getTileset(tile) {\n        let min = 0;\n        let max = tileEngine.tilesets.length - 1;\n        let index, currTile;\n\n        while (min <= max) {\n            index = ((min + max) / 2) | 0;\n            currTile = tileEngine.tilesets[index];\n\n            if (tile >= currTile.firstGrid && tile <= currTile.lastGrid) {\n                return currTile;\n            } else if (currTile.lastGrid < tile) {\n                min = index + 1;\n            } else {\n                max = index - 1;\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Pre-render the tiles to make drawing fast.\n     * @memberof kontra.tileEngine\n     * @private\n     */\n    function preRenderImage() {\n        // draw each layer in order\n        // eslint-disable-next-line no-cond-assign\n        for (let layerIndex = 0, layer; (layer = tileEngine.layers[layerOrder[layerIndex]]); layerIndex++) {\n            for (let dataIndex = 0, len = layer.data.length; dataIndex < len; dataIndex++) {\n                renderTile(layer, dataIndex);\n            }\n        }\n    }\n\n    function renderTile(layer, dataIndex, clear = false) {\n        const tile = layer.data[dataIndex];\n\n        // skip empty tiles (0)\n        if (!tile) {\n            return;\n        }\n\n        const tileset = getTileset(tile);\n        const image = tileset.image;\n\n        const x = (dataIndex % width) * tileWidth;\n        const y = ((dataIndex / width) | 0) * tileHeight;\n\n        const tileOffset = tile - tileset.firstGrid;\n        const w = image.width / tileWidth;\n\n        const sx = (tileOffset % w) * tileWidth;\n        const sy = ((tileOffset / w) | 0) * tileHeight;\n\n        if (clear) {\n            offscreenContext.clearRect(x, y, tileWidth, tileHeight);\n        }\n        offscreenContext.drawImage(image, sx, sy, tileWidth, tileHeight, x, y, tileWidth, tileHeight);\n    }\n\n    return tileEngine;\n};\n","export { default as createTileEngine } from './createTileEngine';\n","export default (row, col, width) => (row - 1) * width + col - 1;\n","export { default as flatIndex } from './flatIndex';\n","import { createUser, INFECTED } from '.';\nimport { mapHeight, mapWidth, mapPaddingX, mapPaddingY } from '../config';\nimport { multiCollides } from '../utils';\nimport { allInfected } from './utils';\nimport { pubsub, GAME_OVER } from '../pubsub';\nimport { messageBox } from '../messageBox';\n\nexport default class {\n    constructor(map) {\n        this.map = map;\n        this.users = [];\n        this.gameOver = false;\n        for (let row = 1; row <= mapHeight + mapPaddingY * 2; row++) {\n            for (let col = 1; col <= mapWidth + mapPaddingX * 2; col++) {\n                const tile = map.tileAtLayer('main', { row, col });\n                if (tile >= 17 && tile <= 20) {\n                    this.users.push(createUser({ map, row: row - mapPaddingY + 1, col: col - mapPaddingX + 1 }));\n                }\n            }\n        }\n        pubsub.subscribe(GAME_OVER, () => (this.gameOver = true));\n    }\n    update() {\n        this.users.forEach(user => user.update());\n    }\n    render() {\n        this.users.forEach(user => user.render());\n    }\n    infect(viruses) {\n        const { users, gameOver } = this;\n        const userVirusCollisions = multiCollides(users, viruses).filter(([user]) => user.status !== INFECTED);\n        if (userVirusCollisions.length === 0) {\n            return;\n        }\n        userVirusCollisions.forEach(([user]) => user.infect());\n        if (gameOver) {\n            return;\n        }\n        if (allInfected(users)) {\n            messageBox.show('all users infected<br>game over');\n            pubsub.publish(GAME_OVER);\n            return;\n        }\n        messageBox.flash('user infected!');\n    }\n}\n","export const ONLINE = 0;\nexport const OFFLINE = 1;\nexport const INFECTED = 2;\n","/* global kontra */\n\nimport { drawUser, INFECTED } from '.';\nimport { tileWidth, tileHeight, collisionRadius } from '../config';\nimport { transformMapCoordinates } from '../utils';\nimport { ONLINE } from '.';\n\nexport default ({ map, row, col }) => {\n    const { x, y } = transformMapCoordinates(map, { row, col });\n    return kontra.sprite({\n        x,\n        y,\n        collisionRadius,\n        infected: false,\n        map,\n        mapX: (col - 1) * tileWidth,\n        mapY: (row - 1) * tileHeight,\n        status: ONLINE,\n        update() {\n            ({ x: this.x, y: this.y } = transformMapCoordinates(this.map, { x: this.mapX, y: this.mapY }));\n        },\n        render() {\n            drawUser(this);\n        },\n        infect() {\n            this.status = INFECTED;\n        }\n    });\n};\n","/* global kontra */\nimport { lightBlue, darkBlue, lightGreen, darkGreen, lightRed, darkRed } from '../config';\nimport { ONLINE, OFFLINE, INFECTED } from './constants';\nimport { degreesToRadians as deg2rad } from '../utils';\n\nconst spriteMapping = {\n    [ONLINE]: { fg: lightBlue, bg: darkBlue },\n    [OFFLINE]: { fg: lightGreen, bg: darkGreen },\n    [INFECTED]: { fg: lightRed, bg: darkRed }\n};\n\nexport default sprite => {\n    const { context: ctx, x, y, status } = sprite;\n    const { fg, bg } = spriteMapping[status];\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = fg;\n    ctx.fillStyle = bg;\n    ctx.beginPath();\n    ctx.moveTo(-40, 40);\n    ctx.lineTo(-40, 20);\n    ctx.arc(-20, 20, 20, deg2rad(180), deg2rad(270));\n    ctx.moveTo(-20, 0);\n    ctx.lineTo(20, 0);\n    ctx.arc(20, 20, 20, deg2rad(270), deg2rad(0));\n    ctx.lineTo(40, 40);\n    ctx.lineTo(-40, 40);\n    ctx.moveTo(-23, 20);\n    ctx.lineTo(-23, 40);\n    ctx.moveTo(23, 20);\n    ctx.lineTo(23, 40);\n    ctx.fill();\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(0, -15, 25, deg2rad(0), deg2rad(360));\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n};\n","export { default as Users } from './Users';\nexport { default as createUser } from './createUser';\nexport { default as drawUser } from './drawUser';\nexport * from './constants';\n","import { INFECTED } from '../constants';\n\nexport default users => users.every(user => user.state === INFECTED);\n","export { default as allInfected } from './allInfected';\n","import { tileHeight, tileWidth } from '../config';\n\nexport default ({ col, row }) => ({\n    sx: (col - 1) * tileWidth + tileWidth / 2,\n    sy: (row - 1) * tileHeight + tileHeight / 2\n});\n","import { degreesToRadians } from '.';\nimport { N, E, S, W } from '../directions';\n\nexport default direction => {\n    switch (direction) {\n        case N:\n            return degreesToRadians(0);\n        case E:\n            return degreesToRadians(90);\n        case S:\n            return degreesToRadians(180);\n        case W:\n            return degreesToRadians(270);\n        default:\n            return null;\n    }\n};\n","export default ({ sx, sy, tileWidth, tileHeight }) => ({\n    col: Math.floor(sx / tileWidth) + 1,\n    row: Math.floor(sy / tileHeight) + 1\n});\n","export default (sprite1, sprite2) => {\n    const dx = sprite1.x - sprite2.x;\n    const dy = sprite1.y - sprite2.y;\n    return Math.sqrt(dx * dx + dy * dy) < sprite1.collisionRadius + sprite2.collisionRadius;\n};\n","export default degrees => (degrees * Math.PI) / 180;\n","export default (a, b) => {\n    const min = Math.min(a, b);\n    const max = Math.max(a, b);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n","export { default as calculateCameraCoordinates } from './calculateCameraCoordinates';\nexport { default as calculateRotation } from './calculateRotation';\nexport { default as degreesToRadians } from './degreesToRadians';\nexport { default as getRandomInt } from './getRandomInt';\nexport { default as transformMapCoordinates } from './transformMapCoordinates';\nexport { default as multiCollides } from './multiCollides';\nexport { default as collides } from './collides';\nexport { default as calculateRowAndCol } from './calculateRowAndCol';\n","import { collides } from '.';\n\nexport default (arr1, arr2) => {\n    const collisions = [];\n    for (let i1 = 0; i1 < arr1.length; i1++) {\n        const sprite1 = arr1[i1];\n        for (let i2 = 0; i2 < arr2.length; i2++) {\n            const sprite2 = arr2[i2];\n            if (collides(sprite1, sprite2)) {\n                collisions.push([sprite1, sprite2]);\n            }\n        }\n    }\n    return collisions;\n};\n","import { canvasHeight, canvasWidth } from '../config';\n\n/**\n * Transforms coordinates relative to the map (either row/col or x/y)\n * to coordinates on the canvas.\n *\n * @param map The map to calculate the coordinates from\n * @param row The row on the map (use either this or y)\n * @param col The column on the map (use either this x)\n * @param x The X coordinate on the map (use either this or col)\n * @param y The Y coordinate on the map (use either this or row)\n * @return {{x: number, y: number}}\n */\nexport default (map, { row, col, x, y }) => {\n    const { tileWidth, tileHeight, sx, sy } = map;\n    const calcX = x !== undefined ? x : (col - 1) * tileWidth;\n    const calcY = y !== undefined ? y : (row - 1) * tileHeight;\n    const nextX = calcX - sx + canvasWidth / 2 + tileWidth / 2;\n    const nextY = calcY - sy + canvasHeight / 2 + tileHeight / 2;\n    return { x: nextX, y: nextY };\n};\n","/* global kontra */\n\nimport { virusStartDirection, virusStartCol, virusStartRow, tileWidth, tileHeight, collisionRadius } from '../config';\nimport { transformMapCoordinates } from '../utils';\nimport { drawVirus, updateVirus } from '.';\n\nexport default map => {\n    const { x, y } = transformMapCoordinates(map, { row: virusStartRow, col: virusStartCol });\n    return kontra.sprite({\n        x,\n        y,\n        collisionRadius,\n        map,\n        mapX: (virusStartCol - 1) * tileWidth,\n        mapY: (virusStartRow - 1) * tileHeight,\n        direction: virusStartDirection,\n        update() {\n            ({ x: this.x, y: this.y, mapX: this.mapX, mapY: this.mapY, direction: this.direction } = updateVirus(this));\n        },\n        render() {\n            drawVirus(this);\n        }\n    });\n};\n","import { lightRed, darkRed } from '../config';\n\n// noinspection JSUnusedGlobalSymbols\nexport default sprite => {\n    const { context: ctx, x, y } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = lightRed;\n    ctx.fillStyle = darkRed;\n    ctx.beginPath();\n    ctx.moveTo(-49, -49);\n    ctx.lineTo(50, -49);\n    ctx.lineTo(50, 50);\n    ctx.lineTo(-49, 50);\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(-49, 0);\n    ctx.lineTo(50, 0);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(0, -49);\n    ctx.lineTo(0, 50);\n    ctx.stroke();\n\n    ctx.restore();\n};\n","import { lightRed, darkRed } from '../config';\nimport { getRandomInt as ri } from '../utils';\n\nexport default sprite => {\n    const { context: ctx, x, y } = sprite;\n    ctx.save();\n    ctx.translate(x, y);\n\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = lightRed;\n    ctx.fillStyle = darkRed;\n    ctx.beginPath();\n    ctx.moveTo(ri(-5, 5), ri(-5, -25)); // 1\n    ctx.lineTo(ri(5, 50), ri(-5, -50)); // 2\n    ctx.lineTo(ri(5, 25), ri(-5, 5)); // 3\n    ctx.lineTo(ri(5, 50), ri(5, 50)); // 4\n    ctx.lineTo(ri(-5, 5), ri(5, 25)); // 5\n    ctx.lineTo(ri(-5, -50), ri(5, 50)); // 6\n    ctx.lineTo(ri(-5, -25), ri(-5, 5)); // 7\n    ctx.lineTo(ri(-5, -50), ri(-5, -50)); // 8\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.restore();\n};\n","export { default as createVirus } from './createVirus';\nexport { default as updateVirus } from './updateVirus';\nexport { default as drawVirus } from './drawVirus';\nexport { default as drawDebugVirus } from './drawDebugVirus';\n","import {\n    switchDirection,\n    isIntersection,\n    directionSwitchMap,\n    getOppositeDirection,\n    directionIsAllowed\n} from '../directions';\nimport { transformMapCoordinates, getRandomInt } from '../utils';\nimport { isInTheMiddle, moveVirus, getBestDirection } from './utils';\nimport { mapWidth, mapHeight, tileWidth, tileHeight } from '../config';\n\nconst visits = Array(mapHeight)\n    .fill()\n    .map(() => Array(mapWidth).fill(0));\n\nexport default sprite => {\n    let { direction, x, y } = sprite;\n    const { map } = sprite;\n    const { mapX, mapY } = moveVirus(sprite);\n    if (isInTheMiddle({ mapX, mapY })) {\n        const tile = map.tileAtLayer('main', { x, y });\n        const col = mapX / tileWidth + 1;\n        const row = mapY / tileHeight + 1;\n        visits[row - 1][col - 1] = visits[row - 1][col - 1] + 1;\n        if (isIntersection(tile)) {\n            const { allowed } = directionSwitchMap[tile];\n            const viable = allowed.filter(\n                dir => dir !== getOppositeDirection(direction) && directionIsAllowed(map, { x, y }, dir)\n            );\n            const bestDirections = getBestDirection({ viable, visits, row, col });\n            direction = bestDirections[getRandomInt(0, bestDirections.length - 1)];\n        } else {\n            direction = switchDirection(map, { x, y }, direction);\n        }\n    }\n    ({ x, y } = transformMapCoordinates(map, { x: mapX, y: mapY }));\n    return {\n        direction,\n        mapY,\n        mapX,\n        x,\n        y\n    };\n};\n","import { N, E, S, W } from '../../directions';\n\nexport default ({ viable, visits, row, col }) => {\n    let minVis = Number.MAX_SAFE_INTEGER;\n    return viable\n        .map(dir => {\n            let vis;\n            switch (dir) {\n                case N:\n                    vis = visits[row - 2][col - 1];\n                    break;\n                case E:\n                    vis = visits[row - 1][col];\n                    break;\n                case S:\n                    vis = visits[row][col - 1];\n                    break;\n                case W:\n                    vis = visits[row - 1][col - 2];\n                    break;\n                default:\n            }\n            minVis = vis < minVis ? vis : minVis;\n            return { dir, vis };\n        })\n        .filter(({ vis }) => vis === minVis)\n        .map(({ dir }) => dir);\n};\n","export { default as isInTheMiddle } from './isInTheMiddle';\nexport { default as moveVirus } from './moveVirus';\nexport { default as getBestDirection } from './getBestDirections';\n","import { tileHeight, tileWidth } from '../../config';\n\nexport default ({ mapX, mapY }) => mapX % tileWidth === 0 && mapY % tileHeight === 0;\n","import { N, E, S, W } from '../../directions';\nimport { virusSpeed } from '../../config';\n\nexport default ({ mapX, mapY, direction }) => {\n    switch (direction) {\n        case N:\n            return { mapX, mapY: mapY - virusSpeed };\n        case E:\n            return { mapX: mapX + virusSpeed, mapY };\n        case S:\n            return { mapX, mapY: mapY + virusSpeed };\n        case W:\n            return { mapX: mapX - virusSpeed, mapY };\n        default:\n            return { mapX, mapY };\n    }\n};\n"],"sourceRoot":""}